
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime';
declare const prisma: unique symbol
export type PrismaPromise<A> = Promise<A> & {[prisma]: true}
type UnwrapPromise<P extends any> = P extends Promise<infer R> ? R : P
type UnwrapTuple<Tuple extends readonly unknown[]> = {
  [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>
};


/**
 * Model student
 */

export type student = {
  student_id: number
  userName: string
  password: string
  education: string
  age: number
  wallet: number
  image: string
  email: string
  token: string
}

/**
 * Model teacher
 */

export type teacher = {
  teacher_id: number
  sumOfRates: number
  email: string
  userName: string
  password: string
  education: string
  description: string
  age: number
  wallet: number
  image: string
  token: string
  Overall_rating: number
  numberOfRates: number
}

/**
 * Model weekDay
 */

export type weekDay = {
  weekDay_id: number
  teacher_id: number
  monday: boolean
  tuesday: boolean
  wednesday: boolean
  thursday: boolean
  friday: boolean
  saturday: boolean
  sunday: boolean
}

/**
 * Model sessions
 */

export type sessions = {
  sessions_id: number
  teacher_id: number
  one: boolean
  two: boolean
  three: boolean
  four: boolean
  five: boolean
  six: boolean
}

/**
 * Model post
 */

export type post = {
  post_id: number
  author_id: number
  Image: string
  status: string
  body: string
  title: string
  price: number
}

/**
 * Model review
 */

export type review = {
  review_id: number
  overallRating: number
  ratesNumber: number
  student_id: number
  teacher_id: number
  comments: string
}

/**
 * Model schedule
 */

export type schedule = {
  scheduel_id: number
  student: number
  teacher: number
  day: string
  session: string
}

/**
 * Model attachement
 */

export type attachement = {
  attachement_id: number
  Type: string
  attachement: string
  body: string
}

/**
 * Model free_course
 */

export type free_course = {
  freeCourse_id: number
  teacher: number
  title: string
  category: string
  Status: string
  document: number
  image: string
}

/**
 * Model feedback
 */

export type feedback = {
  feedback_id: number
  student: number
  stars: number
  comment: string
}


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js (ORM replacement)
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Students
 * const students = await prisma.student.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false
      > {
      /**
       * @private
       */
      private fetcher;
      /**
       * @private
       */
      private readonly dmmf;
      /**
       * @private
       */
      private connectionPromise?;
      /**
       * @private
       */
      private disconnectionPromise?;
      /**
       * @private
       */
      private readonly engineConfig;
      /**
       * @private
       */
      private readonly measurePerformance;

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js (ORM replacement)
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Students
   * const students = await prisma.student.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<any>;

  /**
   * Add a middleware
   */
  $use(cb: Prisma.Middleware): void

  /**
   * Executes a raw query and returns the number of affected rows
   * @example
   * ```
   * // With parameters use prisma.$executeRaw``, values will be escaped automatically
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE id = ${1};`
   * // Or
   * const result = await prisma.$executeRaw('UPDATE User SET cool = $1 WHERE id = $2 ;', true, 1)
  * ```
  * 
  * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
  */
  $executeRaw < T = any > (query: string | TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<number>;

  /**
   * Performs a raw query and returns the SELECT data
   * @example
   * ```
   * // With parameters use prisma.$queryRaw``, values will be escaped automatically
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'ema.il'};`
   * // Or
   * const result = await prisma.$queryRaw('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'ema.il')
  * ```
  * 
  * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
  */
  $queryRaw < T = any > (query: string | TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends PrismaPromise<any>[]>(arg: [...P]): Promise<UnwrapTuple<P>>

      /**
   * `prisma.student`: Exposes CRUD operations for the **student** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Students
    * const students = await prisma.student.findMany()
    * ```
    */
  get student(): Prisma.studentDelegate<GlobalReject>;

  /**
   * `prisma.teacher`: Exposes CRUD operations for the **teacher** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Teachers
    * const teachers = await prisma.teacher.findMany()
    * ```
    */
  get teacher(): Prisma.teacherDelegate<GlobalReject>;

  /**
   * `prisma.weekDay`: Exposes CRUD operations for the **weekDay** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WeekDays
    * const weekDays = await prisma.weekDay.findMany()
    * ```
    */
  get weekDay(): Prisma.weekDayDelegate<GlobalReject>;

  /**
   * `prisma.sessions`: Exposes CRUD operations for the **sessions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.sessions.findMany()
    * ```
    */
  get sessions(): Prisma.sessionsDelegate<GlobalReject>;

  /**
   * `prisma.post`: Exposes CRUD operations for the **post** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Posts
    * const posts = await prisma.post.findMany()
    * ```
    */
  get post(): Prisma.postDelegate<GlobalReject>;

  /**
   * `prisma.review`: Exposes CRUD operations for the **review** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reviews
    * const reviews = await prisma.review.findMany()
    * ```
    */
  get review(): Prisma.reviewDelegate<GlobalReject>;

  /**
   * `prisma.schedule`: Exposes CRUD operations for the **schedule** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Schedules
    * const schedules = await prisma.schedule.findMany()
    * ```
    */
  get schedule(): Prisma.scheduleDelegate<GlobalReject>;

  /**
   * `prisma.attachement`: Exposes CRUD operations for the **attachement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Attachements
    * const attachements = await prisma.attachement.findMany()
    * ```
    */
  get attachement(): Prisma.attachementDelegate<GlobalReject>;

  /**
   * `prisma.free_course`: Exposes CRUD operations for the **free_course** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Free_courses
    * const free_courses = await prisma.free_course.findMany()
    * ```
    */
  get free_course(): Prisma.free_courseDelegate<GlobalReject>;

  /**
   * `prisma.feedback`: Exposes CRUD operations for the **feedback** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Feedbacks
    * const feedbacks = await prisma.feedback.findMany()
    * ```
    */
  get feedback(): Prisma.feedbackDelegate<GlobalReject>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  /**
   * Prisma Client JS version: 2.28.0
   * Query Engine version: 89facabd0366f63911d089156a7a70125bfbcd27
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}
 
  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}
 
  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | null | JsonObject | JsonArray

  /**
   * Same as JsonObject, but allows undefined
   */
  export type InputJsonObject = {[Key in string]?: JsonValue}
 
  export interface InputJsonArray extends Array<JsonValue> {}
 
  export type InputJsonValue = undefined |  string | number | boolean | null | InputJsonObject | InputJsonArray
   type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = {
    [key in keyof T]: T[key] extends false | undefined | null ? never : key
  }[keyof T]

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> = (T | U) extends object ? (Without<T, U> & U) | (Without<U, T> & T) : T | U;


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Buffer
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Exact<A, W = unknown> = 
  W extends unknown ? A extends Narrowable ? Cast<A, W> : Cast<
  {[K in keyof A]: K extends keyof W ? Exact<A[K], W[K]> : never},
  {[K in keyof W]: K extends keyof A ? Exact<A[K], W[K]> : W[K]}>
  : never;

  type Narrowable = string | number | boolean | bigint;

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  export function validator<V>(): <S>(select: Exact<S, V>) => S;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T

  class PrismaClientFetcher {
    private readonly prisma;
    private readonly debug;
    private readonly hooks?;
    constructor(prisma: PrismaClient<any, any>, debug?: boolean, hooks?: Hooks | undefined);
    request<T>(document: any, dataPath?: string[], rootField?: string, typeName?: string, isList?: boolean, callsite?: string): Promise<T>;
    sanitizeMessage(message: string): string;
    protected unpack(document: any, data: any, path: string[], rootField?: string, isList?: boolean): any;
  }

  export const ModelName: {
    student: 'student',
    teacher: 'teacher',
    weekDay: 'weekDay',
    sessions: 'sessions',
    post: 'post',
    review: 'review',
    schedule: 'schedule',
    attachement: 'attachement',
    free_course: 'free_course',
    feedback: 'feedback'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends boolean
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     *  * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your prisma.schema file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  export type Hooks = {
    beforeRequest?: (options: { query: string, path: string[], rootField?: string, typeName?: string, document: any }) => any
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'

  /**
   * These options are being passed in to the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined; 
  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */



  /**
   * Models
   */

  /**
   * Model student
   */


  export type AggregateStudent = {
    _count: StudentCountAggregateOutputType | null
    count: StudentCountAggregateOutputType | null
    _avg: StudentAvgAggregateOutputType | null
    avg: StudentAvgAggregateOutputType | null
    _sum: StudentSumAggregateOutputType | null
    sum: StudentSumAggregateOutputType | null
    _min: StudentMinAggregateOutputType | null
    min: StudentMinAggregateOutputType | null
    _max: StudentMaxAggregateOutputType | null
    max: StudentMaxAggregateOutputType | null
  }

  export type StudentAvgAggregateOutputType = {
    student_id: number | null
    age: number | null
    wallet: number | null
  }

  export type StudentSumAggregateOutputType = {
    student_id: number | null
    age: number | null
    wallet: number | null
  }

  export type StudentMinAggregateOutputType = {
    student_id: number | null
    userName: string | null
    password: string | null
    education: string | null
    age: number | null
    wallet: number | null
    image: string | null
    email: string | null
    token: string | null
  }

  export type StudentMaxAggregateOutputType = {
    student_id: number | null
    userName: string | null
    password: string | null
    education: string | null
    age: number | null
    wallet: number | null
    image: string | null
    email: string | null
    token: string | null
  }

  export type StudentCountAggregateOutputType = {
    student_id: number
    userName: number
    password: number
    education: number
    age: number
    wallet: number
    image: number
    email: number
    token: number
    _all: number
  }


  export type StudentAvgAggregateInputType = {
    student_id?: true
    age?: true
    wallet?: true
  }

  export type StudentSumAggregateInputType = {
    student_id?: true
    age?: true
    wallet?: true
  }

  export type StudentMinAggregateInputType = {
    student_id?: true
    userName?: true
    password?: true
    education?: true
    age?: true
    wallet?: true
    image?: true
    email?: true
    token?: true
  }

  export type StudentMaxAggregateInputType = {
    student_id?: true
    userName?: true
    password?: true
    education?: true
    age?: true
    wallet?: true
    image?: true
    email?: true
    token?: true
  }

  export type StudentCountAggregateInputType = {
    student_id?: true
    userName?: true
    password?: true
    education?: true
    age?: true
    wallet?: true
    image?: true
    email?: true
    token?: true
    _all?: true
  }

  export type StudentAggregateArgs = {
    /**
     * Filter which student to aggregate.
     * 
    **/
    where?: studentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of students to fetch.
     * 
    **/
    orderBy?: Enumerable<studentOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: studentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` students from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` students.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned students
    **/
    _count?: true | StudentCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | StudentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StudentAvgAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_avg`
    **/
    avg?: StudentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StudentSumAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_sum`
    **/
    sum?: StudentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudentMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: StudentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudentMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: StudentMaxAggregateInputType
  }

  export type GetStudentAggregateType<T extends StudentAggregateArgs> = {
        [P in keyof T & keyof AggregateStudent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudent[P]>
      : GetScalarType<T[P], AggregateStudent[P]>
  }


    
    
  export type StudentGroupByArgs = {
    where?: studentWhereInput
    orderBy?: Enumerable<studentOrderByInput>
    by: Array<StudentScalarFieldEnum>
    having?: studentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudentCountAggregateInputType | true
    _avg?: StudentAvgAggregateInputType
    _sum?: StudentSumAggregateInputType
    _min?: StudentMinAggregateInputType
    _max?: StudentMaxAggregateInputType
  }


  export type StudentGroupByOutputType = {
    student_id: number
    userName: string
    password: string
    education: string
    age: number
    wallet: number
    image: string
    email: string
    token: string
    _count: StudentCountAggregateOutputType | null
    _avg: StudentAvgAggregateOutputType | null
    _sum: StudentSumAggregateOutputType | null
    _min: StudentMinAggregateOutputType | null
    _max: StudentMaxAggregateOutputType | null
  }

  type GetStudentGroupByPayload<T extends StudentGroupByArgs> = Promise<
    Array<
      PickArray<StudentGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof StudentGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], StudentGroupByOutputType[P]> 
            : GetScalarType<T[P], StudentGroupByOutputType[P]>
        }
      > 
    >


  export type studentSelect = {
    student_id?: boolean
    userName?: boolean
    password?: boolean
    education?: boolean
    age?: boolean
    wallet?: boolean
    image?: boolean
    email?: boolean
    token?: boolean
    DM?: boolean | feedbackFindManyArgs
    review?: boolean | reviewFindManyArgs
    schedule?: boolean | scheduleFindManyArgs
  }

  export type studentInclude = {
    DM?: boolean | feedbackFindManyArgs
    review?: boolean | reviewFindManyArgs
    schedule?: boolean | scheduleFindManyArgs
  }

  export type studentGetPayload<
    S extends boolean | null | undefined | studentArgs,
    U = keyof S
      > = S extends true
        ? student
    : S extends undefined
    ? never
    : S extends studentArgs | studentFindManyArgs
    ?'include' extends U
    ? student  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'DM'
        ? Array < feedbackGetPayload<S['include'][P]>>  :
        P extends 'review'
        ? Array < reviewGetPayload<S['include'][P]>>  :
        P extends 'schedule'
        ? Array < scheduleGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof student ?student [P]
  : 
          P extends 'DM'
        ? Array < feedbackGetPayload<S['select'][P]>>  :
        P extends 'review'
        ? Array < reviewGetPayload<S['select'][P]>>  :
        P extends 'schedule'
        ? Array < scheduleGetPayload<S['select'][P]>>  : never
  } 
    : student
  : student


  type studentCountArgs = Merge<
    Omit<studentFindManyArgs, 'select' | 'include'> & {
      select?: StudentCountAggregateInputType | true
    }
  >

  export interface studentDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Student that matches the filter.
     * @param {studentFindUniqueArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends studentFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, studentFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'student'> extends True ? CheckSelect<T, Prisma__studentClient<student>, Prisma__studentClient<studentGetPayload<T>>> : CheckSelect<T, Prisma__studentClient<student | null >, Prisma__studentClient<studentGetPayload<T> | null >>

    /**
     * Find the first Student that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {studentFindFirstArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends studentFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, studentFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'student'> extends True ? CheckSelect<T, Prisma__studentClient<student>, Prisma__studentClient<studentGetPayload<T>>> : CheckSelect<T, Prisma__studentClient<student | null >, Prisma__studentClient<studentGetPayload<T> | null >>

    /**
     * Find zero or more Students that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {studentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Students
     * const students = await prisma.student.findMany()
     * 
     * // Get first 10 Students
     * const students = await prisma.student.findMany({ take: 10 })
     * 
     * // Only select the `student_id`
     * const studentWithStudent_idOnly = await prisma.student.findMany({ select: { student_id: true } })
     * 
    **/
    findMany<T extends studentFindManyArgs>(
      args?: SelectSubset<T, studentFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<student>>, PrismaPromise<Array<studentGetPayload<T>>>>

    /**
     * Create a Student.
     * @param {studentCreateArgs} args - Arguments to create a Student.
     * @example
     * // Create one Student
     * const Student = await prisma.student.create({
     *   data: {
     *     // ... data to create a Student
     *   }
     * })
     * 
    **/
    create<T extends studentCreateArgs>(
      args: SelectSubset<T, studentCreateArgs>
    ): CheckSelect<T, Prisma__studentClient<student>, Prisma__studentClient<studentGetPayload<T>>>

    /**
     * Create many Students.
     *     @param {studentCreateManyArgs} args - Arguments to create many Students.
     *     @example
     *     // Create many Students
     *     const student = await prisma.student.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends studentCreateManyArgs>(
      args?: SelectSubset<T, studentCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Student.
     * @param {studentDeleteArgs} args - Arguments to delete one Student.
     * @example
     * // Delete one Student
     * const Student = await prisma.student.delete({
     *   where: {
     *     // ... filter to delete one Student
     *   }
     * })
     * 
    **/
    delete<T extends studentDeleteArgs>(
      args: SelectSubset<T, studentDeleteArgs>
    ): CheckSelect<T, Prisma__studentClient<student>, Prisma__studentClient<studentGetPayload<T>>>

    /**
     * Update one Student.
     * @param {studentUpdateArgs} args - Arguments to update one Student.
     * @example
     * // Update one Student
     * const student = await prisma.student.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends studentUpdateArgs>(
      args: SelectSubset<T, studentUpdateArgs>
    ): CheckSelect<T, Prisma__studentClient<student>, Prisma__studentClient<studentGetPayload<T>>>

    /**
     * Delete zero or more Students.
     * @param {studentDeleteManyArgs} args - Arguments to filter Students to delete.
     * @example
     * // Delete a few Students
     * const { count } = await prisma.student.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends studentDeleteManyArgs>(
      args?: SelectSubset<T, studentDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Students.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {studentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Students
     * const student = await prisma.student.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends studentUpdateManyArgs>(
      args: SelectSubset<T, studentUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Student.
     * @param {studentUpsertArgs} args - Arguments to update or create a Student.
     * @example
     * // Update or create a Student
     * const student = await prisma.student.upsert({
     *   create: {
     *     // ... data to create a Student
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Student we want to update
     *   }
     * })
    **/
    upsert<T extends studentUpsertArgs>(
      args: SelectSubset<T, studentUpsertArgs>
    ): CheckSelect<T, Prisma__studentClient<student>, Prisma__studentClient<studentGetPayload<T>>>

    /**
     * Count the number of Students.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {studentCountArgs} args - Arguments to filter Students to count.
     * @example
     * // Count the number of Students
     * const count = await prisma.student.count({
     *   where: {
     *     // ... the filter for the Students we want to count
     *   }
     * })
    **/
    count<T extends studentCountArgs>(
      args?: Subset<T, studentCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Student.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentAggregateArgs>(args: Subset<T, StudentAggregateArgs>): PrismaPromise<GetStudentAggregateType<T>>

    /**
     * Group by Student.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudentGroupByArgs['orderBy'] }
        : { orderBy?: StudentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for student.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__studentClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    DM<T extends feedbackFindManyArgs = {}>(args?: Subset<T, feedbackFindManyArgs>): CheckSelect<T, PrismaPromise<Array<feedback>>, PrismaPromise<Array<feedbackGetPayload<T>>>>;

    review<T extends reviewFindManyArgs = {}>(args?: Subset<T, reviewFindManyArgs>): CheckSelect<T, PrismaPromise<Array<review>>, PrismaPromise<Array<reviewGetPayload<T>>>>;

    schedule<T extends scheduleFindManyArgs = {}>(args?: Subset<T, scheduleFindManyArgs>): CheckSelect<T, PrismaPromise<Array<schedule>>, PrismaPromise<Array<scheduleGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * student findUnique
   */
  export type studentFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the student
     * 
    **/
    select?: studentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: studentInclude | null
    /**
     * Throw an Error if a student can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which student to fetch.
     * 
    **/
    where: studentWhereUniqueInput
  }


  /**
   * student findFirst
   */
  export type studentFindFirstArgs = {
    /**
     * Select specific fields to fetch from the student
     * 
    **/
    select?: studentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: studentInclude | null
    /**
     * Throw an Error if a student can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which student to fetch.
     * 
    **/
    where?: studentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of students to fetch.
     * 
    **/
    orderBy?: Enumerable<studentOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for students.
     * 
    **/
    cursor?: studentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` students from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` students.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of students.
     * 
    **/
    distinct?: Enumerable<StudentScalarFieldEnum>
  }


  /**
   * student findMany
   */
  export type studentFindManyArgs = {
    /**
     * Select specific fields to fetch from the student
     * 
    **/
    select?: studentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: studentInclude | null
    /**
     * Filter, which students to fetch.
     * 
    **/
    where?: studentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of students to fetch.
     * 
    **/
    orderBy?: Enumerable<studentOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing students.
     * 
    **/
    cursor?: studentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` students from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` students.
     * 
    **/
    skip?: number
    distinct?: Enumerable<StudentScalarFieldEnum>
  }


  /**
   * student create
   */
  export type studentCreateArgs = {
    /**
     * Select specific fields to fetch from the student
     * 
    **/
    select?: studentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: studentInclude | null
    /**
     * The data needed to create a student.
     * 
    **/
    data: XOR<studentCreateInput, studentUncheckedCreateInput>
  }


  /**
   * student createMany
   */
  export type studentCreateManyArgs = {
    data: Enumerable<studentCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * student update
   */
  export type studentUpdateArgs = {
    /**
     * Select specific fields to fetch from the student
     * 
    **/
    select?: studentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: studentInclude | null
    /**
     * The data needed to update a student.
     * 
    **/
    data: XOR<studentUpdateInput, studentUncheckedUpdateInput>
    /**
     * Choose, which student to update.
     * 
    **/
    where: studentWhereUniqueInput
  }


  /**
   * student updateMany
   */
  export type studentUpdateManyArgs = {
    data: XOR<studentUpdateManyMutationInput, studentUncheckedUpdateManyInput>
    where?: studentWhereInput
  }


  /**
   * student upsert
   */
  export type studentUpsertArgs = {
    /**
     * Select specific fields to fetch from the student
     * 
    **/
    select?: studentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: studentInclude | null
    /**
     * The filter to search for the student to update in case it exists.
     * 
    **/
    where: studentWhereUniqueInput
    /**
     * In case the student found by the `where` argument doesn't exist, create a new student with this data.
     * 
    **/
    create: XOR<studentCreateInput, studentUncheckedCreateInput>
    /**
     * In case the student was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<studentUpdateInput, studentUncheckedUpdateInput>
  }


  /**
   * student delete
   */
  export type studentDeleteArgs = {
    /**
     * Select specific fields to fetch from the student
     * 
    **/
    select?: studentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: studentInclude | null
    /**
     * Filter which student to delete.
     * 
    **/
    where: studentWhereUniqueInput
  }


  /**
   * student deleteMany
   */
  export type studentDeleteManyArgs = {
    where?: studentWhereInput
  }


  /**
   * student without action
   */
  export type studentArgs = {
    /**
     * Select specific fields to fetch from the student
     * 
    **/
    select?: studentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: studentInclude | null
  }



  /**
   * Model teacher
   */


  export type AggregateTeacher = {
    _count: TeacherCountAggregateOutputType | null
    count: TeacherCountAggregateOutputType | null
    _avg: TeacherAvgAggregateOutputType | null
    avg: TeacherAvgAggregateOutputType | null
    _sum: TeacherSumAggregateOutputType | null
    sum: TeacherSumAggregateOutputType | null
    _min: TeacherMinAggregateOutputType | null
    min: TeacherMinAggregateOutputType | null
    _max: TeacherMaxAggregateOutputType | null
    max: TeacherMaxAggregateOutputType | null
  }

  export type TeacherAvgAggregateOutputType = {
    teacher_id: number | null
    sumOfRates: number | null
    age: number | null
    wallet: number | null
    Overall_rating: number | null
    numberOfRates: number | null
  }

  export type TeacherSumAggregateOutputType = {
    teacher_id: number | null
    sumOfRates: number | null
    age: number | null
    wallet: number | null
    Overall_rating: number | null
    numberOfRates: number | null
  }

  export type TeacherMinAggregateOutputType = {
    teacher_id: number | null
    sumOfRates: number | null
    email: string | null
    userName: string | null
    password: string | null
    education: string | null
    description: string | null
    age: number | null
    wallet: number | null
    image: string | null
    token: string | null
    Overall_rating: number | null
    numberOfRates: number | null
  }

  export type TeacherMaxAggregateOutputType = {
    teacher_id: number | null
    sumOfRates: number | null
    email: string | null
    userName: string | null
    password: string | null
    education: string | null
    description: string | null
    age: number | null
    wallet: number | null
    image: string | null
    token: string | null
    Overall_rating: number | null
    numberOfRates: number | null
  }

  export type TeacherCountAggregateOutputType = {
    teacher_id: number
    sumOfRates: number
    email: number
    userName: number
    password: number
    education: number
    description: number
    age: number
    wallet: number
    image: number
    token: number
    Overall_rating: number
    numberOfRates: number
    _all: number
  }


  export type TeacherAvgAggregateInputType = {
    teacher_id?: true
    sumOfRates?: true
    age?: true
    wallet?: true
    Overall_rating?: true
    numberOfRates?: true
  }

  export type TeacherSumAggregateInputType = {
    teacher_id?: true
    sumOfRates?: true
    age?: true
    wallet?: true
    Overall_rating?: true
    numberOfRates?: true
  }

  export type TeacherMinAggregateInputType = {
    teacher_id?: true
    sumOfRates?: true
    email?: true
    userName?: true
    password?: true
    education?: true
    description?: true
    age?: true
    wallet?: true
    image?: true
    token?: true
    Overall_rating?: true
    numberOfRates?: true
  }

  export type TeacherMaxAggregateInputType = {
    teacher_id?: true
    sumOfRates?: true
    email?: true
    userName?: true
    password?: true
    education?: true
    description?: true
    age?: true
    wallet?: true
    image?: true
    token?: true
    Overall_rating?: true
    numberOfRates?: true
  }

  export type TeacherCountAggregateInputType = {
    teacher_id?: true
    sumOfRates?: true
    email?: true
    userName?: true
    password?: true
    education?: true
    description?: true
    age?: true
    wallet?: true
    image?: true
    token?: true
    Overall_rating?: true
    numberOfRates?: true
    _all?: true
  }

  export type TeacherAggregateArgs = {
    /**
     * Filter which teacher to aggregate.
     * 
    **/
    where?: teacherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of teachers to fetch.
     * 
    **/
    orderBy?: Enumerable<teacherOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: teacherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` teachers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` teachers.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned teachers
    **/
    _count?: true | TeacherCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | TeacherCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TeacherAvgAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_avg`
    **/
    avg?: TeacherAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TeacherSumAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_sum`
    **/
    sum?: TeacherSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TeacherMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: TeacherMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TeacherMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: TeacherMaxAggregateInputType
  }

  export type GetTeacherAggregateType<T extends TeacherAggregateArgs> = {
        [P in keyof T & keyof AggregateTeacher]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeacher[P]>
      : GetScalarType<T[P], AggregateTeacher[P]>
  }


    
    
  export type TeacherGroupByArgs = {
    where?: teacherWhereInput
    orderBy?: Enumerable<teacherOrderByInput>
    by: Array<TeacherScalarFieldEnum>
    having?: teacherScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeacherCountAggregateInputType | true
    _avg?: TeacherAvgAggregateInputType
    _sum?: TeacherSumAggregateInputType
    _min?: TeacherMinAggregateInputType
    _max?: TeacherMaxAggregateInputType
  }


  export type TeacherGroupByOutputType = {
    teacher_id: number
    sumOfRates: number
    email: string
    userName: string
    password: string
    education: string
    description: string
    age: number
    wallet: number
    image: string
    token: string
    Overall_rating: number
    numberOfRates: number
    _count: TeacherCountAggregateOutputType | null
    _avg: TeacherAvgAggregateOutputType | null
    _sum: TeacherSumAggregateOutputType | null
    _min: TeacherMinAggregateOutputType | null
    _max: TeacherMaxAggregateOutputType | null
  }

  type GetTeacherGroupByPayload<T extends TeacherGroupByArgs> = Promise<
    Array<
      PickArray<TeacherGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof TeacherGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], TeacherGroupByOutputType[P]> 
            : GetScalarType<T[P], TeacherGroupByOutputType[P]>
        }
      > 
    >


  export type teacherSelect = {
    teacher_id?: boolean
    sumOfRates?: boolean
    email?: boolean
    userName?: boolean
    password?: boolean
    education?: boolean
    description?: boolean
    age?: boolean
    wallet?: boolean
    image?: boolean
    token?: boolean
    Overall_rating?: boolean
    numberOfRates?: boolean
    free_course?: boolean | free_courseFindManyArgs
    post?: boolean | postFindManyArgs
    review?: boolean | reviewFindManyArgs
    schedule?: boolean | scheduleFindManyArgs
    sessions?: boolean | sessionsArgs
    weekDay?: boolean | weekDayArgs
  }

  export type teacherInclude = {
    free_course?: boolean | free_courseFindManyArgs
    post?: boolean | postFindManyArgs
    review?: boolean | reviewFindManyArgs
    schedule?: boolean | scheduleFindManyArgs
    sessions?: boolean | sessionsArgs
    weekDay?: boolean | weekDayArgs
  }

  export type teacherGetPayload<
    S extends boolean | null | undefined | teacherArgs,
    U = keyof S
      > = S extends true
        ? teacher
    : S extends undefined
    ? never
    : S extends teacherArgs | teacherFindManyArgs
    ?'include' extends U
    ? teacher  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'free_course'
        ? Array < free_courseGetPayload<S['include'][P]>>  :
        P extends 'post'
        ? Array < postGetPayload<S['include'][P]>>  :
        P extends 'review'
        ? Array < reviewGetPayload<S['include'][P]>>  :
        P extends 'schedule'
        ? Array < scheduleGetPayload<S['include'][P]>>  :
        P extends 'sessions'
        ? sessionsGetPayload<S['include'][P]> | null :
        P extends 'weekDay'
        ? weekDayGetPayload<S['include'][P]> | null : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof teacher ?teacher [P]
  : 
          P extends 'free_course'
        ? Array < free_courseGetPayload<S['select'][P]>>  :
        P extends 'post'
        ? Array < postGetPayload<S['select'][P]>>  :
        P extends 'review'
        ? Array < reviewGetPayload<S['select'][P]>>  :
        P extends 'schedule'
        ? Array < scheduleGetPayload<S['select'][P]>>  :
        P extends 'sessions'
        ? sessionsGetPayload<S['select'][P]> | null :
        P extends 'weekDay'
        ? weekDayGetPayload<S['select'][P]> | null : never
  } 
    : teacher
  : teacher


  type teacherCountArgs = Merge<
    Omit<teacherFindManyArgs, 'select' | 'include'> & {
      select?: TeacherCountAggregateInputType | true
    }
  >

  export interface teacherDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Teacher that matches the filter.
     * @param {teacherFindUniqueArgs} args - Arguments to find a Teacher
     * @example
     * // Get one Teacher
     * const teacher = await prisma.teacher.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends teacherFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, teacherFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'teacher'> extends True ? CheckSelect<T, Prisma__teacherClient<teacher>, Prisma__teacherClient<teacherGetPayload<T>>> : CheckSelect<T, Prisma__teacherClient<teacher | null >, Prisma__teacherClient<teacherGetPayload<T> | null >>

    /**
     * Find the first Teacher that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {teacherFindFirstArgs} args - Arguments to find a Teacher
     * @example
     * // Get one Teacher
     * const teacher = await prisma.teacher.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends teacherFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, teacherFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'teacher'> extends True ? CheckSelect<T, Prisma__teacherClient<teacher>, Prisma__teacherClient<teacherGetPayload<T>>> : CheckSelect<T, Prisma__teacherClient<teacher | null >, Prisma__teacherClient<teacherGetPayload<T> | null >>

    /**
     * Find zero or more Teachers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {teacherFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Teachers
     * const teachers = await prisma.teacher.findMany()
     * 
     * // Get first 10 Teachers
     * const teachers = await prisma.teacher.findMany({ take: 10 })
     * 
     * // Only select the `teacher_id`
     * const teacherWithTeacher_idOnly = await prisma.teacher.findMany({ select: { teacher_id: true } })
     * 
    **/
    findMany<T extends teacherFindManyArgs>(
      args?: SelectSubset<T, teacherFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<teacher>>, PrismaPromise<Array<teacherGetPayload<T>>>>

    /**
     * Create a Teacher.
     * @param {teacherCreateArgs} args - Arguments to create a Teacher.
     * @example
     * // Create one Teacher
     * const Teacher = await prisma.teacher.create({
     *   data: {
     *     // ... data to create a Teacher
     *   }
     * })
     * 
    **/
    create<T extends teacherCreateArgs>(
      args: SelectSubset<T, teacherCreateArgs>
    ): CheckSelect<T, Prisma__teacherClient<teacher>, Prisma__teacherClient<teacherGetPayload<T>>>

    /**
     * Create many Teachers.
     *     @param {teacherCreateManyArgs} args - Arguments to create many Teachers.
     *     @example
     *     // Create many Teachers
     *     const teacher = await prisma.teacher.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends teacherCreateManyArgs>(
      args?: SelectSubset<T, teacherCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Teacher.
     * @param {teacherDeleteArgs} args - Arguments to delete one Teacher.
     * @example
     * // Delete one Teacher
     * const Teacher = await prisma.teacher.delete({
     *   where: {
     *     // ... filter to delete one Teacher
     *   }
     * })
     * 
    **/
    delete<T extends teacherDeleteArgs>(
      args: SelectSubset<T, teacherDeleteArgs>
    ): CheckSelect<T, Prisma__teacherClient<teacher>, Prisma__teacherClient<teacherGetPayload<T>>>

    /**
     * Update one Teacher.
     * @param {teacherUpdateArgs} args - Arguments to update one Teacher.
     * @example
     * // Update one Teacher
     * const teacher = await prisma.teacher.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends teacherUpdateArgs>(
      args: SelectSubset<T, teacherUpdateArgs>
    ): CheckSelect<T, Prisma__teacherClient<teacher>, Prisma__teacherClient<teacherGetPayload<T>>>

    /**
     * Delete zero or more Teachers.
     * @param {teacherDeleteManyArgs} args - Arguments to filter Teachers to delete.
     * @example
     * // Delete a few Teachers
     * const { count } = await prisma.teacher.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends teacherDeleteManyArgs>(
      args?: SelectSubset<T, teacherDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Teachers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {teacherUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Teachers
     * const teacher = await prisma.teacher.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends teacherUpdateManyArgs>(
      args: SelectSubset<T, teacherUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Teacher.
     * @param {teacherUpsertArgs} args - Arguments to update or create a Teacher.
     * @example
     * // Update or create a Teacher
     * const teacher = await prisma.teacher.upsert({
     *   create: {
     *     // ... data to create a Teacher
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Teacher we want to update
     *   }
     * })
    **/
    upsert<T extends teacherUpsertArgs>(
      args: SelectSubset<T, teacherUpsertArgs>
    ): CheckSelect<T, Prisma__teacherClient<teacher>, Prisma__teacherClient<teacherGetPayload<T>>>

    /**
     * Count the number of Teachers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {teacherCountArgs} args - Arguments to filter Teachers to count.
     * @example
     * // Count the number of Teachers
     * const count = await prisma.teacher.count({
     *   where: {
     *     // ... the filter for the Teachers we want to count
     *   }
     * })
    **/
    count<T extends teacherCountArgs>(
      args?: Subset<T, teacherCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeacherCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Teacher.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeacherAggregateArgs>(args: Subset<T, TeacherAggregateArgs>): PrismaPromise<GetTeacherAggregateType<T>>

    /**
     * Group by Teacher.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TeacherGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TeacherGroupByArgs['orderBy'] }
        : { orderBy?: TeacherGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TeacherGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeacherGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for teacher.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__teacherClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    free_course<T extends free_courseFindManyArgs = {}>(args?: Subset<T, free_courseFindManyArgs>): CheckSelect<T, PrismaPromise<Array<free_course>>, PrismaPromise<Array<free_courseGetPayload<T>>>>;

    post<T extends postFindManyArgs = {}>(args?: Subset<T, postFindManyArgs>): CheckSelect<T, PrismaPromise<Array<post>>, PrismaPromise<Array<postGetPayload<T>>>>;

    review<T extends reviewFindManyArgs = {}>(args?: Subset<T, reviewFindManyArgs>): CheckSelect<T, PrismaPromise<Array<review>>, PrismaPromise<Array<reviewGetPayload<T>>>>;

    schedule<T extends scheduleFindManyArgs = {}>(args?: Subset<T, scheduleFindManyArgs>): CheckSelect<T, PrismaPromise<Array<schedule>>, PrismaPromise<Array<scheduleGetPayload<T>>>>;

    sessions<T extends sessionsArgs = {}>(args?: Subset<T, sessionsArgs>): CheckSelect<T, Prisma__sessionsClient<sessions | null >, Prisma__sessionsClient<sessionsGetPayload<T> | null >>;

    weekDay<T extends weekDayArgs = {}>(args?: Subset<T, weekDayArgs>): CheckSelect<T, Prisma__weekDayClient<weekDay | null >, Prisma__weekDayClient<weekDayGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * teacher findUnique
   */
  export type teacherFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the teacher
     * 
    **/
    select?: teacherSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: teacherInclude | null
    /**
     * Throw an Error if a teacher can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which teacher to fetch.
     * 
    **/
    where: teacherWhereUniqueInput
  }


  /**
   * teacher findFirst
   */
  export type teacherFindFirstArgs = {
    /**
     * Select specific fields to fetch from the teacher
     * 
    **/
    select?: teacherSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: teacherInclude | null
    /**
     * Throw an Error if a teacher can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which teacher to fetch.
     * 
    **/
    where?: teacherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of teachers to fetch.
     * 
    **/
    orderBy?: Enumerable<teacherOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for teachers.
     * 
    **/
    cursor?: teacherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` teachers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` teachers.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of teachers.
     * 
    **/
    distinct?: Enumerable<TeacherScalarFieldEnum>
  }


  /**
   * teacher findMany
   */
  export type teacherFindManyArgs = {
    /**
     * Select specific fields to fetch from the teacher
     * 
    **/
    select?: teacherSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: teacherInclude | null
    /**
     * Filter, which teachers to fetch.
     * 
    **/
    where?: teacherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of teachers to fetch.
     * 
    **/
    orderBy?: Enumerable<teacherOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing teachers.
     * 
    **/
    cursor?: teacherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` teachers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` teachers.
     * 
    **/
    skip?: number
    distinct?: Enumerable<TeacherScalarFieldEnum>
  }


  /**
   * teacher create
   */
  export type teacherCreateArgs = {
    /**
     * Select specific fields to fetch from the teacher
     * 
    **/
    select?: teacherSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: teacherInclude | null
    /**
     * The data needed to create a teacher.
     * 
    **/
    data: XOR<teacherCreateInput, teacherUncheckedCreateInput>
  }


  /**
   * teacher createMany
   */
  export type teacherCreateManyArgs = {
    data: Enumerable<teacherCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * teacher update
   */
  export type teacherUpdateArgs = {
    /**
     * Select specific fields to fetch from the teacher
     * 
    **/
    select?: teacherSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: teacherInclude | null
    /**
     * The data needed to update a teacher.
     * 
    **/
    data: XOR<teacherUpdateInput, teacherUncheckedUpdateInput>
    /**
     * Choose, which teacher to update.
     * 
    **/
    where: teacherWhereUniqueInput
  }


  /**
   * teacher updateMany
   */
  export type teacherUpdateManyArgs = {
    data: XOR<teacherUpdateManyMutationInput, teacherUncheckedUpdateManyInput>
    where?: teacherWhereInput
  }


  /**
   * teacher upsert
   */
  export type teacherUpsertArgs = {
    /**
     * Select specific fields to fetch from the teacher
     * 
    **/
    select?: teacherSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: teacherInclude | null
    /**
     * The filter to search for the teacher to update in case it exists.
     * 
    **/
    where: teacherWhereUniqueInput
    /**
     * In case the teacher found by the `where` argument doesn't exist, create a new teacher with this data.
     * 
    **/
    create: XOR<teacherCreateInput, teacherUncheckedCreateInput>
    /**
     * In case the teacher was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<teacherUpdateInput, teacherUncheckedUpdateInput>
  }


  /**
   * teacher delete
   */
  export type teacherDeleteArgs = {
    /**
     * Select specific fields to fetch from the teacher
     * 
    **/
    select?: teacherSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: teacherInclude | null
    /**
     * Filter which teacher to delete.
     * 
    **/
    where: teacherWhereUniqueInput
  }


  /**
   * teacher deleteMany
   */
  export type teacherDeleteManyArgs = {
    where?: teacherWhereInput
  }


  /**
   * teacher without action
   */
  export type teacherArgs = {
    /**
     * Select specific fields to fetch from the teacher
     * 
    **/
    select?: teacherSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: teacherInclude | null
  }



  /**
   * Model weekDay
   */


  export type AggregateWeekDay = {
    _count: WeekDayCountAggregateOutputType | null
    count: WeekDayCountAggregateOutputType | null
    _avg: WeekDayAvgAggregateOutputType | null
    avg: WeekDayAvgAggregateOutputType | null
    _sum: WeekDaySumAggregateOutputType | null
    sum: WeekDaySumAggregateOutputType | null
    _min: WeekDayMinAggregateOutputType | null
    min: WeekDayMinAggregateOutputType | null
    _max: WeekDayMaxAggregateOutputType | null
    max: WeekDayMaxAggregateOutputType | null
  }

  export type WeekDayAvgAggregateOutputType = {
    weekDay_id: number | null
    teacher_id: number | null
  }

  export type WeekDaySumAggregateOutputType = {
    weekDay_id: number | null
    teacher_id: number | null
  }

  export type WeekDayMinAggregateOutputType = {
    weekDay_id: number | null
    teacher_id: number | null
    monday: boolean | null
    tuesday: boolean | null
    wednesday: boolean | null
    thursday: boolean | null
    friday: boolean | null
    saturday: boolean | null
    sunday: boolean | null
  }

  export type WeekDayMaxAggregateOutputType = {
    weekDay_id: number | null
    teacher_id: number | null
    monday: boolean | null
    tuesday: boolean | null
    wednesday: boolean | null
    thursday: boolean | null
    friday: boolean | null
    saturday: boolean | null
    sunday: boolean | null
  }

  export type WeekDayCountAggregateOutputType = {
    weekDay_id: number
    teacher_id: number
    monday: number
    tuesday: number
    wednesday: number
    thursday: number
    friday: number
    saturday: number
    sunday: number
    _all: number
  }


  export type WeekDayAvgAggregateInputType = {
    weekDay_id?: true
    teacher_id?: true
  }

  export type WeekDaySumAggregateInputType = {
    weekDay_id?: true
    teacher_id?: true
  }

  export type WeekDayMinAggregateInputType = {
    weekDay_id?: true
    teacher_id?: true
    monday?: true
    tuesday?: true
    wednesday?: true
    thursday?: true
    friday?: true
    saturday?: true
    sunday?: true
  }

  export type WeekDayMaxAggregateInputType = {
    weekDay_id?: true
    teacher_id?: true
    monday?: true
    tuesday?: true
    wednesday?: true
    thursday?: true
    friday?: true
    saturday?: true
    sunday?: true
  }

  export type WeekDayCountAggregateInputType = {
    weekDay_id?: true
    teacher_id?: true
    monday?: true
    tuesday?: true
    wednesday?: true
    thursday?: true
    friday?: true
    saturday?: true
    sunday?: true
    _all?: true
  }

  export type WeekDayAggregateArgs = {
    /**
     * Filter which weekDay to aggregate.
     * 
    **/
    where?: weekDayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of weekDays to fetch.
     * 
    **/
    orderBy?: Enumerable<weekDayOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: weekDayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` weekDays from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` weekDays.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned weekDays
    **/
    _count?: true | WeekDayCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | WeekDayCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WeekDayAvgAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_avg`
    **/
    avg?: WeekDayAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WeekDaySumAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_sum`
    **/
    sum?: WeekDaySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WeekDayMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: WeekDayMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WeekDayMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: WeekDayMaxAggregateInputType
  }

  export type GetWeekDayAggregateType<T extends WeekDayAggregateArgs> = {
        [P in keyof T & keyof AggregateWeekDay]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWeekDay[P]>
      : GetScalarType<T[P], AggregateWeekDay[P]>
  }


    
    
  export type WeekDayGroupByArgs = {
    where?: weekDayWhereInput
    orderBy?: Enumerable<weekDayOrderByInput>
    by: Array<WeekDayScalarFieldEnum>
    having?: weekDayScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WeekDayCountAggregateInputType | true
    _avg?: WeekDayAvgAggregateInputType
    _sum?: WeekDaySumAggregateInputType
    _min?: WeekDayMinAggregateInputType
    _max?: WeekDayMaxAggregateInputType
  }


  export type WeekDayGroupByOutputType = {
    weekDay_id: number
    teacher_id: number
    monday: boolean
    tuesday: boolean
    wednesday: boolean
    thursday: boolean
    friday: boolean
    saturday: boolean
    sunday: boolean
    _count: WeekDayCountAggregateOutputType | null
    _avg: WeekDayAvgAggregateOutputType | null
    _sum: WeekDaySumAggregateOutputType | null
    _min: WeekDayMinAggregateOutputType | null
    _max: WeekDayMaxAggregateOutputType | null
  }

  type GetWeekDayGroupByPayload<T extends WeekDayGroupByArgs> = Promise<
    Array<
      PickArray<WeekDayGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof WeekDayGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], WeekDayGroupByOutputType[P]> 
            : GetScalarType<T[P], WeekDayGroupByOutputType[P]>
        }
      > 
    >


  export type weekDaySelect = {
    weekDay_id?: boolean
    teacher_id?: boolean
    monday?: boolean
    tuesday?: boolean
    wednesday?: boolean
    thursday?: boolean
    friday?: boolean
    saturday?: boolean
    sunday?: boolean
    teacher?: boolean | teacherArgs
  }

  export type weekDayInclude = {
    teacher?: boolean | teacherArgs
  }

  export type weekDayGetPayload<
    S extends boolean | null | undefined | weekDayArgs,
    U = keyof S
      > = S extends true
        ? weekDay
    : S extends undefined
    ? never
    : S extends weekDayArgs | weekDayFindManyArgs
    ?'include' extends U
    ? weekDay  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'teacher'
        ? teacherGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof weekDay ?weekDay [P]
  : 
          P extends 'teacher'
        ? teacherGetPayload<S['select'][P]> : never
  } 
    : weekDay
  : weekDay


  type weekDayCountArgs = Merge<
    Omit<weekDayFindManyArgs, 'select' | 'include'> & {
      select?: WeekDayCountAggregateInputType | true
    }
  >

  export interface weekDayDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one WeekDay that matches the filter.
     * @param {weekDayFindUniqueArgs} args - Arguments to find a WeekDay
     * @example
     * // Get one WeekDay
     * const weekDay = await prisma.weekDay.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends weekDayFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, weekDayFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'weekDay'> extends True ? CheckSelect<T, Prisma__weekDayClient<weekDay>, Prisma__weekDayClient<weekDayGetPayload<T>>> : CheckSelect<T, Prisma__weekDayClient<weekDay | null >, Prisma__weekDayClient<weekDayGetPayload<T> | null >>

    /**
     * Find the first WeekDay that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {weekDayFindFirstArgs} args - Arguments to find a WeekDay
     * @example
     * // Get one WeekDay
     * const weekDay = await prisma.weekDay.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends weekDayFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, weekDayFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'weekDay'> extends True ? CheckSelect<T, Prisma__weekDayClient<weekDay>, Prisma__weekDayClient<weekDayGetPayload<T>>> : CheckSelect<T, Prisma__weekDayClient<weekDay | null >, Prisma__weekDayClient<weekDayGetPayload<T> | null >>

    /**
     * Find zero or more WeekDays that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {weekDayFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WeekDays
     * const weekDays = await prisma.weekDay.findMany()
     * 
     * // Get first 10 WeekDays
     * const weekDays = await prisma.weekDay.findMany({ take: 10 })
     * 
     * // Only select the `weekDay_id`
     * const weekDayWithWeekDay_idOnly = await prisma.weekDay.findMany({ select: { weekDay_id: true } })
     * 
    **/
    findMany<T extends weekDayFindManyArgs>(
      args?: SelectSubset<T, weekDayFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<weekDay>>, PrismaPromise<Array<weekDayGetPayload<T>>>>

    /**
     * Create a WeekDay.
     * @param {weekDayCreateArgs} args - Arguments to create a WeekDay.
     * @example
     * // Create one WeekDay
     * const WeekDay = await prisma.weekDay.create({
     *   data: {
     *     // ... data to create a WeekDay
     *   }
     * })
     * 
    **/
    create<T extends weekDayCreateArgs>(
      args: SelectSubset<T, weekDayCreateArgs>
    ): CheckSelect<T, Prisma__weekDayClient<weekDay>, Prisma__weekDayClient<weekDayGetPayload<T>>>

    /**
     * Create many WeekDays.
     *     @param {weekDayCreateManyArgs} args - Arguments to create many WeekDays.
     *     @example
     *     // Create many WeekDays
     *     const weekDay = await prisma.weekDay.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends weekDayCreateManyArgs>(
      args?: SelectSubset<T, weekDayCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a WeekDay.
     * @param {weekDayDeleteArgs} args - Arguments to delete one WeekDay.
     * @example
     * // Delete one WeekDay
     * const WeekDay = await prisma.weekDay.delete({
     *   where: {
     *     // ... filter to delete one WeekDay
     *   }
     * })
     * 
    **/
    delete<T extends weekDayDeleteArgs>(
      args: SelectSubset<T, weekDayDeleteArgs>
    ): CheckSelect<T, Prisma__weekDayClient<weekDay>, Prisma__weekDayClient<weekDayGetPayload<T>>>

    /**
     * Update one WeekDay.
     * @param {weekDayUpdateArgs} args - Arguments to update one WeekDay.
     * @example
     * // Update one WeekDay
     * const weekDay = await prisma.weekDay.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends weekDayUpdateArgs>(
      args: SelectSubset<T, weekDayUpdateArgs>
    ): CheckSelect<T, Prisma__weekDayClient<weekDay>, Prisma__weekDayClient<weekDayGetPayload<T>>>

    /**
     * Delete zero or more WeekDays.
     * @param {weekDayDeleteManyArgs} args - Arguments to filter WeekDays to delete.
     * @example
     * // Delete a few WeekDays
     * const { count } = await prisma.weekDay.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends weekDayDeleteManyArgs>(
      args?: SelectSubset<T, weekDayDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more WeekDays.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {weekDayUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WeekDays
     * const weekDay = await prisma.weekDay.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends weekDayUpdateManyArgs>(
      args: SelectSubset<T, weekDayUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one WeekDay.
     * @param {weekDayUpsertArgs} args - Arguments to update or create a WeekDay.
     * @example
     * // Update or create a WeekDay
     * const weekDay = await prisma.weekDay.upsert({
     *   create: {
     *     // ... data to create a WeekDay
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WeekDay we want to update
     *   }
     * })
    **/
    upsert<T extends weekDayUpsertArgs>(
      args: SelectSubset<T, weekDayUpsertArgs>
    ): CheckSelect<T, Prisma__weekDayClient<weekDay>, Prisma__weekDayClient<weekDayGetPayload<T>>>

    /**
     * Count the number of WeekDays.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {weekDayCountArgs} args - Arguments to filter WeekDays to count.
     * @example
     * // Count the number of WeekDays
     * const count = await prisma.weekDay.count({
     *   where: {
     *     // ... the filter for the WeekDays we want to count
     *   }
     * })
    **/
    count<T extends weekDayCountArgs>(
      args?: Subset<T, weekDayCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WeekDayCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WeekDay.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeekDayAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WeekDayAggregateArgs>(args: Subset<T, WeekDayAggregateArgs>): PrismaPromise<GetWeekDayAggregateType<T>>

    /**
     * Group by WeekDay.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeekDayGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WeekDayGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WeekDayGroupByArgs['orderBy'] }
        : { orderBy?: WeekDayGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WeekDayGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWeekDayGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for weekDay.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__weekDayClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    teacher<T extends teacherArgs = {}>(args?: Subset<T, teacherArgs>): CheckSelect<T, Prisma__teacherClient<teacher | null >, Prisma__teacherClient<teacherGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * weekDay findUnique
   */
  export type weekDayFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the weekDay
     * 
    **/
    select?: weekDaySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: weekDayInclude | null
    /**
     * Throw an Error if a weekDay can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which weekDay to fetch.
     * 
    **/
    where: weekDayWhereUniqueInput
  }


  /**
   * weekDay findFirst
   */
  export type weekDayFindFirstArgs = {
    /**
     * Select specific fields to fetch from the weekDay
     * 
    **/
    select?: weekDaySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: weekDayInclude | null
    /**
     * Throw an Error if a weekDay can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which weekDay to fetch.
     * 
    **/
    where?: weekDayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of weekDays to fetch.
     * 
    **/
    orderBy?: Enumerable<weekDayOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for weekDays.
     * 
    **/
    cursor?: weekDayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` weekDays from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` weekDays.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of weekDays.
     * 
    **/
    distinct?: Enumerable<WeekDayScalarFieldEnum>
  }


  /**
   * weekDay findMany
   */
  export type weekDayFindManyArgs = {
    /**
     * Select specific fields to fetch from the weekDay
     * 
    **/
    select?: weekDaySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: weekDayInclude | null
    /**
     * Filter, which weekDays to fetch.
     * 
    **/
    where?: weekDayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of weekDays to fetch.
     * 
    **/
    orderBy?: Enumerable<weekDayOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing weekDays.
     * 
    **/
    cursor?: weekDayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` weekDays from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` weekDays.
     * 
    **/
    skip?: number
    distinct?: Enumerable<WeekDayScalarFieldEnum>
  }


  /**
   * weekDay create
   */
  export type weekDayCreateArgs = {
    /**
     * Select specific fields to fetch from the weekDay
     * 
    **/
    select?: weekDaySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: weekDayInclude | null
    /**
     * The data needed to create a weekDay.
     * 
    **/
    data: XOR<weekDayCreateInput, weekDayUncheckedCreateInput>
  }


  /**
   * weekDay createMany
   */
  export type weekDayCreateManyArgs = {
    data: Enumerable<weekDayCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * weekDay update
   */
  export type weekDayUpdateArgs = {
    /**
     * Select specific fields to fetch from the weekDay
     * 
    **/
    select?: weekDaySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: weekDayInclude | null
    /**
     * The data needed to update a weekDay.
     * 
    **/
    data: XOR<weekDayUpdateInput, weekDayUncheckedUpdateInput>
    /**
     * Choose, which weekDay to update.
     * 
    **/
    where: weekDayWhereUniqueInput
  }


  /**
   * weekDay updateMany
   */
  export type weekDayUpdateManyArgs = {
    data: XOR<weekDayUpdateManyMutationInput, weekDayUncheckedUpdateManyInput>
    where?: weekDayWhereInput
  }


  /**
   * weekDay upsert
   */
  export type weekDayUpsertArgs = {
    /**
     * Select specific fields to fetch from the weekDay
     * 
    **/
    select?: weekDaySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: weekDayInclude | null
    /**
     * The filter to search for the weekDay to update in case it exists.
     * 
    **/
    where: weekDayWhereUniqueInput
    /**
     * In case the weekDay found by the `where` argument doesn't exist, create a new weekDay with this data.
     * 
    **/
    create: XOR<weekDayCreateInput, weekDayUncheckedCreateInput>
    /**
     * In case the weekDay was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<weekDayUpdateInput, weekDayUncheckedUpdateInput>
  }


  /**
   * weekDay delete
   */
  export type weekDayDeleteArgs = {
    /**
     * Select specific fields to fetch from the weekDay
     * 
    **/
    select?: weekDaySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: weekDayInclude | null
    /**
     * Filter which weekDay to delete.
     * 
    **/
    where: weekDayWhereUniqueInput
  }


  /**
   * weekDay deleteMany
   */
  export type weekDayDeleteManyArgs = {
    where?: weekDayWhereInput
  }


  /**
   * weekDay without action
   */
  export type weekDayArgs = {
    /**
     * Select specific fields to fetch from the weekDay
     * 
    **/
    select?: weekDaySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: weekDayInclude | null
  }



  /**
   * Model sessions
   */


  export type AggregateSessions = {
    _count: SessionsCountAggregateOutputType | null
    count: SessionsCountAggregateOutputType | null
    _avg: SessionsAvgAggregateOutputType | null
    avg: SessionsAvgAggregateOutputType | null
    _sum: SessionsSumAggregateOutputType | null
    sum: SessionsSumAggregateOutputType | null
    _min: SessionsMinAggregateOutputType | null
    min: SessionsMinAggregateOutputType | null
    _max: SessionsMaxAggregateOutputType | null
    max: SessionsMaxAggregateOutputType | null
  }

  export type SessionsAvgAggregateOutputType = {
    sessions_id: number | null
    teacher_id: number | null
  }

  export type SessionsSumAggregateOutputType = {
    sessions_id: number | null
    teacher_id: number | null
  }

  export type SessionsMinAggregateOutputType = {
    sessions_id: number | null
    teacher_id: number | null
    one: boolean | null
    two: boolean | null
    three: boolean | null
    four: boolean | null
    five: boolean | null
    six: boolean | null
  }

  export type SessionsMaxAggregateOutputType = {
    sessions_id: number | null
    teacher_id: number | null
    one: boolean | null
    two: boolean | null
    three: boolean | null
    four: boolean | null
    five: boolean | null
    six: boolean | null
  }

  export type SessionsCountAggregateOutputType = {
    sessions_id: number
    teacher_id: number
    one: number
    two: number
    three: number
    four: number
    five: number
    six: number
    _all: number
  }


  export type SessionsAvgAggregateInputType = {
    sessions_id?: true
    teacher_id?: true
  }

  export type SessionsSumAggregateInputType = {
    sessions_id?: true
    teacher_id?: true
  }

  export type SessionsMinAggregateInputType = {
    sessions_id?: true
    teacher_id?: true
    one?: true
    two?: true
    three?: true
    four?: true
    five?: true
    six?: true
  }

  export type SessionsMaxAggregateInputType = {
    sessions_id?: true
    teacher_id?: true
    one?: true
    two?: true
    three?: true
    four?: true
    five?: true
    six?: true
  }

  export type SessionsCountAggregateInputType = {
    sessions_id?: true
    teacher_id?: true
    one?: true
    two?: true
    three?: true
    four?: true
    five?: true
    six?: true
    _all?: true
  }

  export type SessionsAggregateArgs = {
    /**
     * Filter which sessions to aggregate.
     * 
    **/
    where?: sessionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sessions to fetch.
     * 
    **/
    orderBy?: Enumerable<sessionsOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: sessionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sessions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sessions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned sessions
    **/
    _count?: true | SessionsCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | SessionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SessionsAvgAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_avg`
    **/
    avg?: SessionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SessionsSumAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_sum`
    **/
    sum?: SessionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionsMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: SessionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionsMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: SessionsMaxAggregateInputType
  }

  export type GetSessionsAggregateType<T extends SessionsAggregateArgs> = {
        [P in keyof T & keyof AggregateSessions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSessions[P]>
      : GetScalarType<T[P], AggregateSessions[P]>
  }


    
    
  export type SessionsGroupByArgs = {
    where?: sessionsWhereInput
    orderBy?: Enumerable<sessionsOrderByInput>
    by: Array<SessionsScalarFieldEnum>
    having?: sessionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionsCountAggregateInputType | true
    _avg?: SessionsAvgAggregateInputType
    _sum?: SessionsSumAggregateInputType
    _min?: SessionsMinAggregateInputType
    _max?: SessionsMaxAggregateInputType
  }


  export type SessionsGroupByOutputType = {
    sessions_id: number
    teacher_id: number
    one: boolean
    two: boolean
    three: boolean
    four: boolean
    five: boolean
    six: boolean
    _count: SessionsCountAggregateOutputType | null
    _avg: SessionsAvgAggregateOutputType | null
    _sum: SessionsSumAggregateOutputType | null
    _min: SessionsMinAggregateOutputType | null
    _max: SessionsMaxAggregateOutputType | null
  }

  type GetSessionsGroupByPayload<T extends SessionsGroupByArgs> = Promise<
    Array<
      PickArray<SessionsGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof SessionsGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], SessionsGroupByOutputType[P]> 
            : GetScalarType<T[P], SessionsGroupByOutputType[P]>
        }
      > 
    >


  export type sessionsSelect = {
    sessions_id?: boolean
    teacher_id?: boolean
    one?: boolean
    two?: boolean
    three?: boolean
    four?: boolean
    five?: boolean
    six?: boolean
    teacher?: boolean | teacherArgs
  }

  export type sessionsInclude = {
    teacher?: boolean | teacherArgs
  }

  export type sessionsGetPayload<
    S extends boolean | null | undefined | sessionsArgs,
    U = keyof S
      > = S extends true
        ? sessions
    : S extends undefined
    ? never
    : S extends sessionsArgs | sessionsFindManyArgs
    ?'include' extends U
    ? sessions  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'teacher'
        ? teacherGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof sessions ?sessions [P]
  : 
          P extends 'teacher'
        ? teacherGetPayload<S['select'][P]> : never
  } 
    : sessions
  : sessions


  type sessionsCountArgs = Merge<
    Omit<sessionsFindManyArgs, 'select' | 'include'> & {
      select?: SessionsCountAggregateInputType | true
    }
  >

  export interface sessionsDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Sessions that matches the filter.
     * @param {sessionsFindUniqueArgs} args - Arguments to find a Sessions
     * @example
     * // Get one Sessions
     * const sessions = await prisma.sessions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends sessionsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, sessionsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'sessions'> extends True ? CheckSelect<T, Prisma__sessionsClient<sessions>, Prisma__sessionsClient<sessionsGetPayload<T>>> : CheckSelect<T, Prisma__sessionsClient<sessions | null >, Prisma__sessionsClient<sessionsGetPayload<T> | null >>

    /**
     * Find the first Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessionsFindFirstArgs} args - Arguments to find a Sessions
     * @example
     * // Get one Sessions
     * const sessions = await prisma.sessions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends sessionsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, sessionsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'sessions'> extends True ? CheckSelect<T, Prisma__sessionsClient<sessions>, Prisma__sessionsClient<sessionsGetPayload<T>>> : CheckSelect<T, Prisma__sessionsClient<sessions | null >, Prisma__sessionsClient<sessionsGetPayload<T> | null >>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessionsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.sessions.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.sessions.findMany({ take: 10 })
     * 
     * // Only select the `sessions_id`
     * const sessionsWithSessions_idOnly = await prisma.sessions.findMany({ select: { sessions_id: true } })
     * 
    **/
    findMany<T extends sessionsFindManyArgs>(
      args?: SelectSubset<T, sessionsFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<sessions>>, PrismaPromise<Array<sessionsGetPayload<T>>>>

    /**
     * Create a Sessions.
     * @param {sessionsCreateArgs} args - Arguments to create a Sessions.
     * @example
     * // Create one Sessions
     * const Sessions = await prisma.sessions.create({
     *   data: {
     *     // ... data to create a Sessions
     *   }
     * })
     * 
    **/
    create<T extends sessionsCreateArgs>(
      args: SelectSubset<T, sessionsCreateArgs>
    ): CheckSelect<T, Prisma__sessionsClient<sessions>, Prisma__sessionsClient<sessionsGetPayload<T>>>

    /**
     * Create many Sessions.
     *     @param {sessionsCreateManyArgs} args - Arguments to create many Sessions.
     *     @example
     *     // Create many Sessions
     *     const sessions = await prisma.sessions.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends sessionsCreateManyArgs>(
      args?: SelectSubset<T, sessionsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Sessions.
     * @param {sessionsDeleteArgs} args - Arguments to delete one Sessions.
     * @example
     * // Delete one Sessions
     * const Sessions = await prisma.sessions.delete({
     *   where: {
     *     // ... filter to delete one Sessions
     *   }
     * })
     * 
    **/
    delete<T extends sessionsDeleteArgs>(
      args: SelectSubset<T, sessionsDeleteArgs>
    ): CheckSelect<T, Prisma__sessionsClient<sessions>, Prisma__sessionsClient<sessionsGetPayload<T>>>

    /**
     * Update one Sessions.
     * @param {sessionsUpdateArgs} args - Arguments to update one Sessions.
     * @example
     * // Update one Sessions
     * const sessions = await prisma.sessions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends sessionsUpdateArgs>(
      args: SelectSubset<T, sessionsUpdateArgs>
    ): CheckSelect<T, Prisma__sessionsClient<sessions>, Prisma__sessionsClient<sessionsGetPayload<T>>>

    /**
     * Delete zero or more Sessions.
     * @param {sessionsDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.sessions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends sessionsDeleteManyArgs>(
      args?: SelectSubset<T, sessionsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const sessions = await prisma.sessions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends sessionsUpdateManyArgs>(
      args: SelectSubset<T, sessionsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Sessions.
     * @param {sessionsUpsertArgs} args - Arguments to update or create a Sessions.
     * @example
     * // Update or create a Sessions
     * const sessions = await prisma.sessions.upsert({
     *   create: {
     *     // ... data to create a Sessions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Sessions we want to update
     *   }
     * })
    **/
    upsert<T extends sessionsUpsertArgs>(
      args: SelectSubset<T, sessionsUpsertArgs>
    ): CheckSelect<T, Prisma__sessionsClient<sessions>, Prisma__sessionsClient<sessionsGetPayload<T>>>

    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessionsCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.sessions.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends sessionsCountArgs>(
      args?: Subset<T, sessionsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionsAggregateArgs>(args: Subset<T, SessionsAggregateArgs>): PrismaPromise<GetSessionsAggregateType<T>>

    /**
     * Group by Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionsGroupByArgs['orderBy'] }
        : { orderBy?: SessionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionsGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for sessions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__sessionsClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    teacher<T extends teacherArgs = {}>(args?: Subset<T, teacherArgs>): CheckSelect<T, Prisma__teacherClient<teacher | null >, Prisma__teacherClient<teacherGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * sessions findUnique
   */
  export type sessionsFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the sessions
     * 
    **/
    select?: sessionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: sessionsInclude | null
    /**
     * Throw an Error if a sessions can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which sessions to fetch.
     * 
    **/
    where: sessionsWhereUniqueInput
  }


  /**
   * sessions findFirst
   */
  export type sessionsFindFirstArgs = {
    /**
     * Select specific fields to fetch from the sessions
     * 
    **/
    select?: sessionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: sessionsInclude | null
    /**
     * Throw an Error if a sessions can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which sessions to fetch.
     * 
    **/
    where?: sessionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sessions to fetch.
     * 
    **/
    orderBy?: Enumerable<sessionsOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sessions.
     * 
    **/
    cursor?: sessionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sessions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sessions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sessions.
     * 
    **/
    distinct?: Enumerable<SessionsScalarFieldEnum>
  }


  /**
   * sessions findMany
   */
  export type sessionsFindManyArgs = {
    /**
     * Select specific fields to fetch from the sessions
     * 
    **/
    select?: sessionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: sessionsInclude | null
    /**
     * Filter, which sessions to fetch.
     * 
    **/
    where?: sessionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sessions to fetch.
     * 
    **/
    orderBy?: Enumerable<sessionsOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing sessions.
     * 
    **/
    cursor?: sessionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sessions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sessions.
     * 
    **/
    skip?: number
    distinct?: Enumerable<SessionsScalarFieldEnum>
  }


  /**
   * sessions create
   */
  export type sessionsCreateArgs = {
    /**
     * Select specific fields to fetch from the sessions
     * 
    **/
    select?: sessionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: sessionsInclude | null
    /**
     * The data needed to create a sessions.
     * 
    **/
    data: XOR<sessionsCreateInput, sessionsUncheckedCreateInput>
  }


  /**
   * sessions createMany
   */
  export type sessionsCreateManyArgs = {
    data: Enumerable<sessionsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * sessions update
   */
  export type sessionsUpdateArgs = {
    /**
     * Select specific fields to fetch from the sessions
     * 
    **/
    select?: sessionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: sessionsInclude | null
    /**
     * The data needed to update a sessions.
     * 
    **/
    data: XOR<sessionsUpdateInput, sessionsUncheckedUpdateInput>
    /**
     * Choose, which sessions to update.
     * 
    **/
    where: sessionsWhereUniqueInput
  }


  /**
   * sessions updateMany
   */
  export type sessionsUpdateManyArgs = {
    data: XOR<sessionsUpdateManyMutationInput, sessionsUncheckedUpdateManyInput>
    where?: sessionsWhereInput
  }


  /**
   * sessions upsert
   */
  export type sessionsUpsertArgs = {
    /**
     * Select specific fields to fetch from the sessions
     * 
    **/
    select?: sessionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: sessionsInclude | null
    /**
     * The filter to search for the sessions to update in case it exists.
     * 
    **/
    where: sessionsWhereUniqueInput
    /**
     * In case the sessions found by the `where` argument doesn't exist, create a new sessions with this data.
     * 
    **/
    create: XOR<sessionsCreateInput, sessionsUncheckedCreateInput>
    /**
     * In case the sessions was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<sessionsUpdateInput, sessionsUncheckedUpdateInput>
  }


  /**
   * sessions delete
   */
  export type sessionsDeleteArgs = {
    /**
     * Select specific fields to fetch from the sessions
     * 
    **/
    select?: sessionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: sessionsInclude | null
    /**
     * Filter which sessions to delete.
     * 
    **/
    where: sessionsWhereUniqueInput
  }


  /**
   * sessions deleteMany
   */
  export type sessionsDeleteManyArgs = {
    where?: sessionsWhereInput
  }


  /**
   * sessions without action
   */
  export type sessionsArgs = {
    /**
     * Select specific fields to fetch from the sessions
     * 
    **/
    select?: sessionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: sessionsInclude | null
  }



  /**
   * Model post
   */


  export type AggregatePost = {
    _count: PostCountAggregateOutputType | null
    count: PostCountAggregateOutputType | null
    _avg: PostAvgAggregateOutputType | null
    avg: PostAvgAggregateOutputType | null
    _sum: PostSumAggregateOutputType | null
    sum: PostSumAggregateOutputType | null
    _min: PostMinAggregateOutputType | null
    min: PostMinAggregateOutputType | null
    _max: PostMaxAggregateOutputType | null
    max: PostMaxAggregateOutputType | null
  }

  export type PostAvgAggregateOutputType = {
    post_id: number | null
    author_id: number | null
    price: number | null
  }

  export type PostSumAggregateOutputType = {
    post_id: number | null
    author_id: number | null
    price: number | null
  }

  export type PostMinAggregateOutputType = {
    post_id: number | null
    author_id: number | null
    Image: string | null
    status: string | null
    body: string | null
    title: string | null
    price: number | null
  }

  export type PostMaxAggregateOutputType = {
    post_id: number | null
    author_id: number | null
    Image: string | null
    status: string | null
    body: string | null
    title: string | null
    price: number | null
  }

  export type PostCountAggregateOutputType = {
    post_id: number
    author_id: number
    Image: number
    status: number
    body: number
    title: number
    price: number
    _all: number
  }


  export type PostAvgAggregateInputType = {
    post_id?: true
    author_id?: true
    price?: true
  }

  export type PostSumAggregateInputType = {
    post_id?: true
    author_id?: true
    price?: true
  }

  export type PostMinAggregateInputType = {
    post_id?: true
    author_id?: true
    Image?: true
    status?: true
    body?: true
    title?: true
    price?: true
  }

  export type PostMaxAggregateInputType = {
    post_id?: true
    author_id?: true
    Image?: true
    status?: true
    body?: true
    title?: true
    price?: true
  }

  export type PostCountAggregateInputType = {
    post_id?: true
    author_id?: true
    Image?: true
    status?: true
    body?: true
    title?: true
    price?: true
    _all?: true
  }

  export type PostAggregateArgs = {
    /**
     * Filter which post to aggregate.
     * 
    **/
    where?: postWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of posts to fetch.
     * 
    **/
    orderBy?: Enumerable<postOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: postWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` posts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` posts.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned posts
    **/
    _count?: true | PostCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | PostCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PostAvgAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_avg`
    **/
    avg?: PostAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PostSumAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_sum`
    **/
    sum?: PostSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PostMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: PostMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PostMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: PostMaxAggregateInputType
  }

  export type GetPostAggregateType<T extends PostAggregateArgs> = {
        [P in keyof T & keyof AggregatePost]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePost[P]>
      : GetScalarType<T[P], AggregatePost[P]>
  }


    
    
  export type PostGroupByArgs = {
    where?: postWhereInput
    orderBy?: Enumerable<postOrderByInput>
    by: Array<PostScalarFieldEnum>
    having?: postScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PostCountAggregateInputType | true
    _avg?: PostAvgAggregateInputType
    _sum?: PostSumAggregateInputType
    _min?: PostMinAggregateInputType
    _max?: PostMaxAggregateInputType
  }


  export type PostGroupByOutputType = {
    post_id: number
    author_id: number
    Image: string
    status: string
    body: string
    title: string
    price: number
    _count: PostCountAggregateOutputType | null
    _avg: PostAvgAggregateOutputType | null
    _sum: PostSumAggregateOutputType | null
    _min: PostMinAggregateOutputType | null
    _max: PostMaxAggregateOutputType | null
  }

  type GetPostGroupByPayload<T extends PostGroupByArgs> = Promise<
    Array<
      PickArray<PostGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof PostGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], PostGroupByOutputType[P]> 
            : GetScalarType<T[P], PostGroupByOutputType[P]>
        }
      > 
    >


  export type postSelect = {
    post_id?: boolean
    author_id?: boolean
    Image?: boolean
    status?: boolean
    body?: boolean
    title?: boolean
    price?: boolean
    author?: boolean | teacherArgs
  }

  export type postInclude = {
    author?: boolean | teacherArgs
  }

  export type postGetPayload<
    S extends boolean | null | undefined | postArgs,
    U = keyof S
      > = S extends true
        ? post
    : S extends undefined
    ? never
    : S extends postArgs | postFindManyArgs
    ?'include' extends U
    ? post  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'author'
        ? teacherGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof post ?post [P]
  : 
          P extends 'author'
        ? teacherGetPayload<S['select'][P]> : never
  } 
    : post
  : post


  type postCountArgs = Merge<
    Omit<postFindManyArgs, 'select' | 'include'> & {
      select?: PostCountAggregateInputType | true
    }
  >

  export interface postDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Post that matches the filter.
     * @param {postFindUniqueArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends postFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, postFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'post'> extends True ? CheckSelect<T, Prisma__postClient<post>, Prisma__postClient<postGetPayload<T>>> : CheckSelect<T, Prisma__postClient<post | null >, Prisma__postClient<postGetPayload<T> | null >>

    /**
     * Find the first Post that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {postFindFirstArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends postFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, postFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'post'> extends True ? CheckSelect<T, Prisma__postClient<post>, Prisma__postClient<postGetPayload<T>>> : CheckSelect<T, Prisma__postClient<post | null >, Prisma__postClient<postGetPayload<T> | null >>

    /**
     * Find zero or more Posts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {postFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Posts
     * const posts = await prisma.post.findMany()
     * 
     * // Get first 10 Posts
     * const posts = await prisma.post.findMany({ take: 10 })
     * 
     * // Only select the `post_id`
     * const postWithPost_idOnly = await prisma.post.findMany({ select: { post_id: true } })
     * 
    **/
    findMany<T extends postFindManyArgs>(
      args?: SelectSubset<T, postFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<post>>, PrismaPromise<Array<postGetPayload<T>>>>

    /**
     * Create a Post.
     * @param {postCreateArgs} args - Arguments to create a Post.
     * @example
     * // Create one Post
     * const Post = await prisma.post.create({
     *   data: {
     *     // ... data to create a Post
     *   }
     * })
     * 
    **/
    create<T extends postCreateArgs>(
      args: SelectSubset<T, postCreateArgs>
    ): CheckSelect<T, Prisma__postClient<post>, Prisma__postClient<postGetPayload<T>>>

    /**
     * Create many Posts.
     *     @param {postCreateManyArgs} args - Arguments to create many Posts.
     *     @example
     *     // Create many Posts
     *     const post = await prisma.post.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends postCreateManyArgs>(
      args?: SelectSubset<T, postCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Post.
     * @param {postDeleteArgs} args - Arguments to delete one Post.
     * @example
     * // Delete one Post
     * const Post = await prisma.post.delete({
     *   where: {
     *     // ... filter to delete one Post
     *   }
     * })
     * 
    **/
    delete<T extends postDeleteArgs>(
      args: SelectSubset<T, postDeleteArgs>
    ): CheckSelect<T, Prisma__postClient<post>, Prisma__postClient<postGetPayload<T>>>

    /**
     * Update one Post.
     * @param {postUpdateArgs} args - Arguments to update one Post.
     * @example
     * // Update one Post
     * const post = await prisma.post.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends postUpdateArgs>(
      args: SelectSubset<T, postUpdateArgs>
    ): CheckSelect<T, Prisma__postClient<post>, Prisma__postClient<postGetPayload<T>>>

    /**
     * Delete zero or more Posts.
     * @param {postDeleteManyArgs} args - Arguments to filter Posts to delete.
     * @example
     * // Delete a few Posts
     * const { count } = await prisma.post.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends postDeleteManyArgs>(
      args?: SelectSubset<T, postDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Posts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {postUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Posts
     * const post = await prisma.post.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends postUpdateManyArgs>(
      args: SelectSubset<T, postUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Post.
     * @param {postUpsertArgs} args - Arguments to update or create a Post.
     * @example
     * // Update or create a Post
     * const post = await prisma.post.upsert({
     *   create: {
     *     // ... data to create a Post
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Post we want to update
     *   }
     * })
    **/
    upsert<T extends postUpsertArgs>(
      args: SelectSubset<T, postUpsertArgs>
    ): CheckSelect<T, Prisma__postClient<post>, Prisma__postClient<postGetPayload<T>>>

    /**
     * Count the number of Posts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {postCountArgs} args - Arguments to filter Posts to count.
     * @example
     * // Count the number of Posts
     * const count = await prisma.post.count({
     *   where: {
     *     // ... the filter for the Posts we want to count
     *   }
     * })
    **/
    count<T extends postCountArgs>(
      args?: Subset<T, postCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PostCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Post.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PostAggregateArgs>(args: Subset<T, PostAggregateArgs>): PrismaPromise<GetPostAggregateType<T>>

    /**
     * Group by Post.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PostGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PostGroupByArgs['orderBy'] }
        : { orderBy?: PostGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PostGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPostGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for post.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__postClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    author<T extends teacherArgs = {}>(args?: Subset<T, teacherArgs>): CheckSelect<T, Prisma__teacherClient<teacher | null >, Prisma__teacherClient<teacherGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * post findUnique
   */
  export type postFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the post
     * 
    **/
    select?: postSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: postInclude | null
    /**
     * Throw an Error if a post can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which post to fetch.
     * 
    **/
    where: postWhereUniqueInput
  }


  /**
   * post findFirst
   */
  export type postFindFirstArgs = {
    /**
     * Select specific fields to fetch from the post
     * 
    **/
    select?: postSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: postInclude | null
    /**
     * Throw an Error if a post can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which post to fetch.
     * 
    **/
    where?: postWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of posts to fetch.
     * 
    **/
    orderBy?: Enumerable<postOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for posts.
     * 
    **/
    cursor?: postWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` posts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` posts.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of posts.
     * 
    **/
    distinct?: Enumerable<PostScalarFieldEnum>
  }


  /**
   * post findMany
   */
  export type postFindManyArgs = {
    /**
     * Select specific fields to fetch from the post
     * 
    **/
    select?: postSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: postInclude | null
    /**
     * Filter, which posts to fetch.
     * 
    **/
    where?: postWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of posts to fetch.
     * 
    **/
    orderBy?: Enumerable<postOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing posts.
     * 
    **/
    cursor?: postWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` posts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` posts.
     * 
    **/
    skip?: number
    distinct?: Enumerable<PostScalarFieldEnum>
  }


  /**
   * post create
   */
  export type postCreateArgs = {
    /**
     * Select specific fields to fetch from the post
     * 
    **/
    select?: postSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: postInclude | null
    /**
     * The data needed to create a post.
     * 
    **/
    data: XOR<postCreateInput, postUncheckedCreateInput>
  }


  /**
   * post createMany
   */
  export type postCreateManyArgs = {
    data: Enumerable<postCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * post update
   */
  export type postUpdateArgs = {
    /**
     * Select specific fields to fetch from the post
     * 
    **/
    select?: postSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: postInclude | null
    /**
     * The data needed to update a post.
     * 
    **/
    data: XOR<postUpdateInput, postUncheckedUpdateInput>
    /**
     * Choose, which post to update.
     * 
    **/
    where: postWhereUniqueInput
  }


  /**
   * post updateMany
   */
  export type postUpdateManyArgs = {
    data: XOR<postUpdateManyMutationInput, postUncheckedUpdateManyInput>
    where?: postWhereInput
  }


  /**
   * post upsert
   */
  export type postUpsertArgs = {
    /**
     * Select specific fields to fetch from the post
     * 
    **/
    select?: postSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: postInclude | null
    /**
     * The filter to search for the post to update in case it exists.
     * 
    **/
    where: postWhereUniqueInput
    /**
     * In case the post found by the `where` argument doesn't exist, create a new post with this data.
     * 
    **/
    create: XOR<postCreateInput, postUncheckedCreateInput>
    /**
     * In case the post was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<postUpdateInput, postUncheckedUpdateInput>
  }


  /**
   * post delete
   */
  export type postDeleteArgs = {
    /**
     * Select specific fields to fetch from the post
     * 
    **/
    select?: postSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: postInclude | null
    /**
     * Filter which post to delete.
     * 
    **/
    where: postWhereUniqueInput
  }


  /**
   * post deleteMany
   */
  export type postDeleteManyArgs = {
    where?: postWhereInput
  }


  /**
   * post without action
   */
  export type postArgs = {
    /**
     * Select specific fields to fetch from the post
     * 
    **/
    select?: postSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: postInclude | null
  }



  /**
   * Model review
   */


  export type AggregateReview = {
    _count: ReviewCountAggregateOutputType | null
    count: ReviewCountAggregateOutputType | null
    _avg: ReviewAvgAggregateOutputType | null
    avg: ReviewAvgAggregateOutputType | null
    _sum: ReviewSumAggregateOutputType | null
    sum: ReviewSumAggregateOutputType | null
    _min: ReviewMinAggregateOutputType | null
    min: ReviewMinAggregateOutputType | null
    _max: ReviewMaxAggregateOutputType | null
    max: ReviewMaxAggregateOutputType | null
  }

  export type ReviewAvgAggregateOutputType = {
    review_id: number | null
    overallRating: number | null
    ratesNumber: number | null
    student_id: number | null
    teacher_id: number | null
  }

  export type ReviewSumAggregateOutputType = {
    review_id: number | null
    overallRating: number | null
    ratesNumber: number | null
    student_id: number | null
    teacher_id: number | null
  }

  export type ReviewMinAggregateOutputType = {
    review_id: number | null
    overallRating: number | null
    ratesNumber: number | null
    student_id: number | null
    teacher_id: number | null
    comments: string | null
  }

  export type ReviewMaxAggregateOutputType = {
    review_id: number | null
    overallRating: number | null
    ratesNumber: number | null
    student_id: number | null
    teacher_id: number | null
    comments: string | null
  }

  export type ReviewCountAggregateOutputType = {
    review_id: number
    overallRating: number
    ratesNumber: number
    student_id: number
    teacher_id: number
    comments: number
    _all: number
  }


  export type ReviewAvgAggregateInputType = {
    review_id?: true
    overallRating?: true
    ratesNumber?: true
    student_id?: true
    teacher_id?: true
  }

  export type ReviewSumAggregateInputType = {
    review_id?: true
    overallRating?: true
    ratesNumber?: true
    student_id?: true
    teacher_id?: true
  }

  export type ReviewMinAggregateInputType = {
    review_id?: true
    overallRating?: true
    ratesNumber?: true
    student_id?: true
    teacher_id?: true
    comments?: true
  }

  export type ReviewMaxAggregateInputType = {
    review_id?: true
    overallRating?: true
    ratesNumber?: true
    student_id?: true
    teacher_id?: true
    comments?: true
  }

  export type ReviewCountAggregateInputType = {
    review_id?: true
    overallRating?: true
    ratesNumber?: true
    student_id?: true
    teacher_id?: true
    comments?: true
    _all?: true
  }

  export type ReviewAggregateArgs = {
    /**
     * Filter which review to aggregate.
     * 
    **/
    where?: reviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reviews to fetch.
     * 
    **/
    orderBy?: Enumerable<reviewOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: reviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reviews from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reviews.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned reviews
    **/
    _count?: true | ReviewCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | ReviewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReviewAvgAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_avg`
    **/
    avg?: ReviewAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReviewSumAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_sum`
    **/
    sum?: ReviewSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReviewMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: ReviewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReviewMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: ReviewMaxAggregateInputType
  }

  export type GetReviewAggregateType<T extends ReviewAggregateArgs> = {
        [P in keyof T & keyof AggregateReview]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReview[P]>
      : GetScalarType<T[P], AggregateReview[P]>
  }


    
    
  export type ReviewGroupByArgs = {
    where?: reviewWhereInput
    orderBy?: Enumerable<reviewOrderByInput>
    by: Array<ReviewScalarFieldEnum>
    having?: reviewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReviewCountAggregateInputType | true
    _avg?: ReviewAvgAggregateInputType
    _sum?: ReviewSumAggregateInputType
    _min?: ReviewMinAggregateInputType
    _max?: ReviewMaxAggregateInputType
  }


  export type ReviewGroupByOutputType = {
    review_id: number
    overallRating: number
    ratesNumber: number
    student_id: number
    teacher_id: number
    comments: string
    _count: ReviewCountAggregateOutputType | null
    _avg: ReviewAvgAggregateOutputType | null
    _sum: ReviewSumAggregateOutputType | null
    _min: ReviewMinAggregateOutputType | null
    _max: ReviewMaxAggregateOutputType | null
  }

  type GetReviewGroupByPayload<T extends ReviewGroupByArgs> = Promise<
    Array<
      PickArray<ReviewGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof ReviewGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], ReviewGroupByOutputType[P]> 
            : GetScalarType<T[P], ReviewGroupByOutputType[P]>
        }
      > 
    >


  export type reviewSelect = {
    review_id?: boolean
    overallRating?: boolean
    ratesNumber?: boolean
    student_id?: boolean
    teacher_id?: boolean
    comments?: boolean
    student?: boolean | studentArgs
    teacher?: boolean | teacherArgs
  }

  export type reviewInclude = {
    student?: boolean | studentArgs
    teacher?: boolean | teacherArgs
  }

  export type reviewGetPayload<
    S extends boolean | null | undefined | reviewArgs,
    U = keyof S
      > = S extends true
        ? review
    : S extends undefined
    ? never
    : S extends reviewArgs | reviewFindManyArgs
    ?'include' extends U
    ? review  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'student'
        ? studentGetPayload<S['include'][P]> :
        P extends 'teacher'
        ? teacherGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof review ?review [P]
  : 
          P extends 'student'
        ? studentGetPayload<S['select'][P]> :
        P extends 'teacher'
        ? teacherGetPayload<S['select'][P]> : never
  } 
    : review
  : review


  type reviewCountArgs = Merge<
    Omit<reviewFindManyArgs, 'select' | 'include'> & {
      select?: ReviewCountAggregateInputType | true
    }
  >

  export interface reviewDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Review that matches the filter.
     * @param {reviewFindUniqueArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends reviewFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, reviewFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'review'> extends True ? CheckSelect<T, Prisma__reviewClient<review>, Prisma__reviewClient<reviewGetPayload<T>>> : CheckSelect<T, Prisma__reviewClient<review | null >, Prisma__reviewClient<reviewGetPayload<T> | null >>

    /**
     * Find the first Review that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reviewFindFirstArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends reviewFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, reviewFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'review'> extends True ? CheckSelect<T, Prisma__reviewClient<review>, Prisma__reviewClient<reviewGetPayload<T>>> : CheckSelect<T, Prisma__reviewClient<review | null >, Prisma__reviewClient<reviewGetPayload<T> | null >>

    /**
     * Find zero or more Reviews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reviewFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reviews
     * const reviews = await prisma.review.findMany()
     * 
     * // Get first 10 Reviews
     * const reviews = await prisma.review.findMany({ take: 10 })
     * 
     * // Only select the `review_id`
     * const reviewWithReview_idOnly = await prisma.review.findMany({ select: { review_id: true } })
     * 
    **/
    findMany<T extends reviewFindManyArgs>(
      args?: SelectSubset<T, reviewFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<review>>, PrismaPromise<Array<reviewGetPayload<T>>>>

    /**
     * Create a Review.
     * @param {reviewCreateArgs} args - Arguments to create a Review.
     * @example
     * // Create one Review
     * const Review = await prisma.review.create({
     *   data: {
     *     // ... data to create a Review
     *   }
     * })
     * 
    **/
    create<T extends reviewCreateArgs>(
      args: SelectSubset<T, reviewCreateArgs>
    ): CheckSelect<T, Prisma__reviewClient<review>, Prisma__reviewClient<reviewGetPayload<T>>>

    /**
     * Create many Reviews.
     *     @param {reviewCreateManyArgs} args - Arguments to create many Reviews.
     *     @example
     *     // Create many Reviews
     *     const review = await prisma.review.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends reviewCreateManyArgs>(
      args?: SelectSubset<T, reviewCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Review.
     * @param {reviewDeleteArgs} args - Arguments to delete one Review.
     * @example
     * // Delete one Review
     * const Review = await prisma.review.delete({
     *   where: {
     *     // ... filter to delete one Review
     *   }
     * })
     * 
    **/
    delete<T extends reviewDeleteArgs>(
      args: SelectSubset<T, reviewDeleteArgs>
    ): CheckSelect<T, Prisma__reviewClient<review>, Prisma__reviewClient<reviewGetPayload<T>>>

    /**
     * Update one Review.
     * @param {reviewUpdateArgs} args - Arguments to update one Review.
     * @example
     * // Update one Review
     * const review = await prisma.review.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends reviewUpdateArgs>(
      args: SelectSubset<T, reviewUpdateArgs>
    ): CheckSelect<T, Prisma__reviewClient<review>, Prisma__reviewClient<reviewGetPayload<T>>>

    /**
     * Delete zero or more Reviews.
     * @param {reviewDeleteManyArgs} args - Arguments to filter Reviews to delete.
     * @example
     * // Delete a few Reviews
     * const { count } = await prisma.review.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends reviewDeleteManyArgs>(
      args?: SelectSubset<T, reviewDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reviewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reviews
     * const review = await prisma.review.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends reviewUpdateManyArgs>(
      args: SelectSubset<T, reviewUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Review.
     * @param {reviewUpsertArgs} args - Arguments to update or create a Review.
     * @example
     * // Update or create a Review
     * const review = await prisma.review.upsert({
     *   create: {
     *     // ... data to create a Review
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Review we want to update
     *   }
     * })
    **/
    upsert<T extends reviewUpsertArgs>(
      args: SelectSubset<T, reviewUpsertArgs>
    ): CheckSelect<T, Prisma__reviewClient<review>, Prisma__reviewClient<reviewGetPayload<T>>>

    /**
     * Count the number of Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reviewCountArgs} args - Arguments to filter Reviews to count.
     * @example
     * // Count the number of Reviews
     * const count = await prisma.review.count({
     *   where: {
     *     // ... the filter for the Reviews we want to count
     *   }
     * })
    **/
    count<T extends reviewCountArgs>(
      args?: Subset<T, reviewCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReviewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Review.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReviewAggregateArgs>(args: Subset<T, ReviewAggregateArgs>): PrismaPromise<GetReviewAggregateType<T>>

    /**
     * Group by Review.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReviewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReviewGroupByArgs['orderBy'] }
        : { orderBy?: ReviewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReviewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReviewGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for review.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__reviewClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    student<T extends studentArgs = {}>(args?: Subset<T, studentArgs>): CheckSelect<T, Prisma__studentClient<student | null >, Prisma__studentClient<studentGetPayload<T> | null >>;

    teacher<T extends teacherArgs = {}>(args?: Subset<T, teacherArgs>): CheckSelect<T, Prisma__teacherClient<teacher | null >, Prisma__teacherClient<teacherGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * review findUnique
   */
  export type reviewFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the review
     * 
    **/
    select?: reviewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: reviewInclude | null
    /**
     * Throw an Error if a review can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which review to fetch.
     * 
    **/
    where: reviewWhereUniqueInput
  }


  /**
   * review findFirst
   */
  export type reviewFindFirstArgs = {
    /**
     * Select specific fields to fetch from the review
     * 
    **/
    select?: reviewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: reviewInclude | null
    /**
     * Throw an Error if a review can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which review to fetch.
     * 
    **/
    where?: reviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reviews to fetch.
     * 
    **/
    orderBy?: Enumerable<reviewOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for reviews.
     * 
    **/
    cursor?: reviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reviews from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reviews.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of reviews.
     * 
    **/
    distinct?: Enumerable<ReviewScalarFieldEnum>
  }


  /**
   * review findMany
   */
  export type reviewFindManyArgs = {
    /**
     * Select specific fields to fetch from the review
     * 
    **/
    select?: reviewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: reviewInclude | null
    /**
     * Filter, which reviews to fetch.
     * 
    **/
    where?: reviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reviews to fetch.
     * 
    **/
    orderBy?: Enumerable<reviewOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing reviews.
     * 
    **/
    cursor?: reviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reviews from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reviews.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ReviewScalarFieldEnum>
  }


  /**
   * review create
   */
  export type reviewCreateArgs = {
    /**
     * Select specific fields to fetch from the review
     * 
    **/
    select?: reviewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: reviewInclude | null
    /**
     * The data needed to create a review.
     * 
    **/
    data: XOR<reviewCreateInput, reviewUncheckedCreateInput>
  }


  /**
   * review createMany
   */
  export type reviewCreateManyArgs = {
    data: Enumerable<reviewCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * review update
   */
  export type reviewUpdateArgs = {
    /**
     * Select specific fields to fetch from the review
     * 
    **/
    select?: reviewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: reviewInclude | null
    /**
     * The data needed to update a review.
     * 
    **/
    data: XOR<reviewUpdateInput, reviewUncheckedUpdateInput>
    /**
     * Choose, which review to update.
     * 
    **/
    where: reviewWhereUniqueInput
  }


  /**
   * review updateMany
   */
  export type reviewUpdateManyArgs = {
    data: XOR<reviewUpdateManyMutationInput, reviewUncheckedUpdateManyInput>
    where?: reviewWhereInput
  }


  /**
   * review upsert
   */
  export type reviewUpsertArgs = {
    /**
     * Select specific fields to fetch from the review
     * 
    **/
    select?: reviewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: reviewInclude | null
    /**
     * The filter to search for the review to update in case it exists.
     * 
    **/
    where: reviewWhereUniqueInput
    /**
     * In case the review found by the `where` argument doesn't exist, create a new review with this data.
     * 
    **/
    create: XOR<reviewCreateInput, reviewUncheckedCreateInput>
    /**
     * In case the review was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<reviewUpdateInput, reviewUncheckedUpdateInput>
  }


  /**
   * review delete
   */
  export type reviewDeleteArgs = {
    /**
     * Select specific fields to fetch from the review
     * 
    **/
    select?: reviewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: reviewInclude | null
    /**
     * Filter which review to delete.
     * 
    **/
    where: reviewWhereUniqueInput
  }


  /**
   * review deleteMany
   */
  export type reviewDeleteManyArgs = {
    where?: reviewWhereInput
  }


  /**
   * review without action
   */
  export type reviewArgs = {
    /**
     * Select specific fields to fetch from the review
     * 
    **/
    select?: reviewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: reviewInclude | null
  }



  /**
   * Model schedule
   */


  export type AggregateSchedule = {
    _count: ScheduleCountAggregateOutputType | null
    count: ScheduleCountAggregateOutputType | null
    _avg: ScheduleAvgAggregateOutputType | null
    avg: ScheduleAvgAggregateOutputType | null
    _sum: ScheduleSumAggregateOutputType | null
    sum: ScheduleSumAggregateOutputType | null
    _min: ScheduleMinAggregateOutputType | null
    min: ScheduleMinAggregateOutputType | null
    _max: ScheduleMaxAggregateOutputType | null
    max: ScheduleMaxAggregateOutputType | null
  }

  export type ScheduleAvgAggregateOutputType = {
    scheduel_id: number | null
    student: number | null
    teacher: number | null
  }

  export type ScheduleSumAggregateOutputType = {
    scheduel_id: number | null
    student: number | null
    teacher: number | null
  }

  export type ScheduleMinAggregateOutputType = {
    scheduel_id: number | null
    student: number | null
    teacher: number | null
    day: string | null
    session: string | null
  }

  export type ScheduleMaxAggregateOutputType = {
    scheduel_id: number | null
    student: number | null
    teacher: number | null
    day: string | null
    session: string | null
  }

  export type ScheduleCountAggregateOutputType = {
    scheduel_id: number
    student: number
    teacher: number
    day: number
    session: number
    _all: number
  }


  export type ScheduleAvgAggregateInputType = {
    scheduel_id?: true
    student?: true
    teacher?: true
  }

  export type ScheduleSumAggregateInputType = {
    scheduel_id?: true
    student?: true
    teacher?: true
  }

  export type ScheduleMinAggregateInputType = {
    scheduel_id?: true
    student?: true
    teacher?: true
    day?: true
    session?: true
  }

  export type ScheduleMaxAggregateInputType = {
    scheduel_id?: true
    student?: true
    teacher?: true
    day?: true
    session?: true
  }

  export type ScheduleCountAggregateInputType = {
    scheduel_id?: true
    student?: true
    teacher?: true
    day?: true
    session?: true
    _all?: true
  }

  export type ScheduleAggregateArgs = {
    /**
     * Filter which schedule to aggregate.
     * 
    **/
    where?: scheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of schedules to fetch.
     * 
    **/
    orderBy?: Enumerable<scheduleOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: scheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` schedules from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` schedules.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned schedules
    **/
    _count?: true | ScheduleCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | ScheduleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ScheduleAvgAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_avg`
    **/
    avg?: ScheduleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ScheduleSumAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_sum`
    **/
    sum?: ScheduleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ScheduleMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: ScheduleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ScheduleMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: ScheduleMaxAggregateInputType
  }

  export type GetScheduleAggregateType<T extends ScheduleAggregateArgs> = {
        [P in keyof T & keyof AggregateSchedule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSchedule[P]>
      : GetScalarType<T[P], AggregateSchedule[P]>
  }


    
    
  export type ScheduleGroupByArgs = {
    where?: scheduleWhereInput
    orderBy?: Enumerable<scheduleOrderByInput>
    by: Array<ScheduleScalarFieldEnum>
    having?: scheduleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ScheduleCountAggregateInputType | true
    _avg?: ScheduleAvgAggregateInputType
    _sum?: ScheduleSumAggregateInputType
    _min?: ScheduleMinAggregateInputType
    _max?: ScheduleMaxAggregateInputType
  }


  export type ScheduleGroupByOutputType = {
    scheduel_id: number
    student: number
    teacher: number
    day: string
    session: string
    _count: ScheduleCountAggregateOutputType | null
    _avg: ScheduleAvgAggregateOutputType | null
    _sum: ScheduleSumAggregateOutputType | null
    _min: ScheduleMinAggregateOutputType | null
    _max: ScheduleMaxAggregateOutputType | null
  }

  type GetScheduleGroupByPayload<T extends ScheduleGroupByArgs> = Promise<
    Array<
      PickArray<ScheduleGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof ScheduleGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], ScheduleGroupByOutputType[P]> 
            : GetScalarType<T[P], ScheduleGroupByOutputType[P]>
        }
      > 
    >


  export type scheduleSelect = {
    scheduel_id?: boolean
    student?: boolean
    teacher?: boolean
    day?: boolean
    session?: boolean
    student_id?: boolean | studentArgs
    teacher_id?: boolean | teacherArgs
  }

  export type scheduleInclude = {
    student_id?: boolean | studentArgs
    teacher_id?: boolean | teacherArgs
  }

  export type scheduleGetPayload<
    S extends boolean | null | undefined | scheduleArgs,
    U = keyof S
      > = S extends true
        ? schedule
    : S extends undefined
    ? never
    : S extends scheduleArgs | scheduleFindManyArgs
    ?'include' extends U
    ? schedule  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'student_id'
        ? studentGetPayload<S['include'][P]> :
        P extends 'teacher_id'
        ? teacherGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof schedule ?schedule [P]
  : 
          P extends 'student_id'
        ? studentGetPayload<S['select'][P]> :
        P extends 'teacher_id'
        ? teacherGetPayload<S['select'][P]> : never
  } 
    : schedule
  : schedule


  type scheduleCountArgs = Merge<
    Omit<scheduleFindManyArgs, 'select' | 'include'> & {
      select?: ScheduleCountAggregateInputType | true
    }
  >

  export interface scheduleDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Schedule that matches the filter.
     * @param {scheduleFindUniqueArgs} args - Arguments to find a Schedule
     * @example
     * // Get one Schedule
     * const schedule = await prisma.schedule.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends scheduleFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, scheduleFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'schedule'> extends True ? CheckSelect<T, Prisma__scheduleClient<schedule>, Prisma__scheduleClient<scheduleGetPayload<T>>> : CheckSelect<T, Prisma__scheduleClient<schedule | null >, Prisma__scheduleClient<scheduleGetPayload<T> | null >>

    /**
     * Find the first Schedule that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {scheduleFindFirstArgs} args - Arguments to find a Schedule
     * @example
     * // Get one Schedule
     * const schedule = await prisma.schedule.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends scheduleFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, scheduleFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'schedule'> extends True ? CheckSelect<T, Prisma__scheduleClient<schedule>, Prisma__scheduleClient<scheduleGetPayload<T>>> : CheckSelect<T, Prisma__scheduleClient<schedule | null >, Prisma__scheduleClient<scheduleGetPayload<T> | null >>

    /**
     * Find zero or more Schedules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {scheduleFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Schedules
     * const schedules = await prisma.schedule.findMany()
     * 
     * // Get first 10 Schedules
     * const schedules = await prisma.schedule.findMany({ take: 10 })
     * 
     * // Only select the `scheduel_id`
     * const scheduleWithScheduel_idOnly = await prisma.schedule.findMany({ select: { scheduel_id: true } })
     * 
    **/
    findMany<T extends scheduleFindManyArgs>(
      args?: SelectSubset<T, scheduleFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<schedule>>, PrismaPromise<Array<scheduleGetPayload<T>>>>

    /**
     * Create a Schedule.
     * @param {scheduleCreateArgs} args - Arguments to create a Schedule.
     * @example
     * // Create one Schedule
     * const Schedule = await prisma.schedule.create({
     *   data: {
     *     // ... data to create a Schedule
     *   }
     * })
     * 
    **/
    create<T extends scheduleCreateArgs>(
      args: SelectSubset<T, scheduleCreateArgs>
    ): CheckSelect<T, Prisma__scheduleClient<schedule>, Prisma__scheduleClient<scheduleGetPayload<T>>>

    /**
     * Create many Schedules.
     *     @param {scheduleCreateManyArgs} args - Arguments to create many Schedules.
     *     @example
     *     // Create many Schedules
     *     const schedule = await prisma.schedule.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends scheduleCreateManyArgs>(
      args?: SelectSubset<T, scheduleCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Schedule.
     * @param {scheduleDeleteArgs} args - Arguments to delete one Schedule.
     * @example
     * // Delete one Schedule
     * const Schedule = await prisma.schedule.delete({
     *   where: {
     *     // ... filter to delete one Schedule
     *   }
     * })
     * 
    **/
    delete<T extends scheduleDeleteArgs>(
      args: SelectSubset<T, scheduleDeleteArgs>
    ): CheckSelect<T, Prisma__scheduleClient<schedule>, Prisma__scheduleClient<scheduleGetPayload<T>>>

    /**
     * Update one Schedule.
     * @param {scheduleUpdateArgs} args - Arguments to update one Schedule.
     * @example
     * // Update one Schedule
     * const schedule = await prisma.schedule.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends scheduleUpdateArgs>(
      args: SelectSubset<T, scheduleUpdateArgs>
    ): CheckSelect<T, Prisma__scheduleClient<schedule>, Prisma__scheduleClient<scheduleGetPayload<T>>>

    /**
     * Delete zero or more Schedules.
     * @param {scheduleDeleteManyArgs} args - Arguments to filter Schedules to delete.
     * @example
     * // Delete a few Schedules
     * const { count } = await prisma.schedule.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends scheduleDeleteManyArgs>(
      args?: SelectSubset<T, scheduleDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Schedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {scheduleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Schedules
     * const schedule = await prisma.schedule.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends scheduleUpdateManyArgs>(
      args: SelectSubset<T, scheduleUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Schedule.
     * @param {scheduleUpsertArgs} args - Arguments to update or create a Schedule.
     * @example
     * // Update or create a Schedule
     * const schedule = await prisma.schedule.upsert({
     *   create: {
     *     // ... data to create a Schedule
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Schedule we want to update
     *   }
     * })
    **/
    upsert<T extends scheduleUpsertArgs>(
      args: SelectSubset<T, scheduleUpsertArgs>
    ): CheckSelect<T, Prisma__scheduleClient<schedule>, Prisma__scheduleClient<scheduleGetPayload<T>>>

    /**
     * Count the number of Schedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {scheduleCountArgs} args - Arguments to filter Schedules to count.
     * @example
     * // Count the number of Schedules
     * const count = await prisma.schedule.count({
     *   where: {
     *     // ... the filter for the Schedules we want to count
     *   }
     * })
    **/
    count<T extends scheduleCountArgs>(
      args?: Subset<T, scheduleCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ScheduleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Schedule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ScheduleAggregateArgs>(args: Subset<T, ScheduleAggregateArgs>): PrismaPromise<GetScheduleAggregateType<T>>

    /**
     * Group by Schedule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ScheduleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ScheduleGroupByArgs['orderBy'] }
        : { orderBy?: ScheduleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ScheduleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetScheduleGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for schedule.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__scheduleClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    student_id<T extends studentArgs = {}>(args?: Subset<T, studentArgs>): CheckSelect<T, Prisma__studentClient<student | null >, Prisma__studentClient<studentGetPayload<T> | null >>;

    teacher_id<T extends teacherArgs = {}>(args?: Subset<T, teacherArgs>): CheckSelect<T, Prisma__teacherClient<teacher | null >, Prisma__teacherClient<teacherGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * schedule findUnique
   */
  export type scheduleFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the schedule
     * 
    **/
    select?: scheduleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: scheduleInclude | null
    /**
     * Throw an Error if a schedule can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which schedule to fetch.
     * 
    **/
    where: scheduleWhereUniqueInput
  }


  /**
   * schedule findFirst
   */
  export type scheduleFindFirstArgs = {
    /**
     * Select specific fields to fetch from the schedule
     * 
    **/
    select?: scheduleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: scheduleInclude | null
    /**
     * Throw an Error if a schedule can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which schedule to fetch.
     * 
    **/
    where?: scheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of schedules to fetch.
     * 
    **/
    orderBy?: Enumerable<scheduleOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for schedules.
     * 
    **/
    cursor?: scheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` schedules from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` schedules.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of schedules.
     * 
    **/
    distinct?: Enumerable<ScheduleScalarFieldEnum>
  }


  /**
   * schedule findMany
   */
  export type scheduleFindManyArgs = {
    /**
     * Select specific fields to fetch from the schedule
     * 
    **/
    select?: scheduleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: scheduleInclude | null
    /**
     * Filter, which schedules to fetch.
     * 
    **/
    where?: scheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of schedules to fetch.
     * 
    **/
    orderBy?: Enumerable<scheduleOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing schedules.
     * 
    **/
    cursor?: scheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` schedules from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` schedules.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ScheduleScalarFieldEnum>
  }


  /**
   * schedule create
   */
  export type scheduleCreateArgs = {
    /**
     * Select specific fields to fetch from the schedule
     * 
    **/
    select?: scheduleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: scheduleInclude | null
    /**
     * The data needed to create a schedule.
     * 
    **/
    data: XOR<scheduleCreateInput, scheduleUncheckedCreateInput>
  }


  /**
   * schedule createMany
   */
  export type scheduleCreateManyArgs = {
    data: Enumerable<scheduleCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * schedule update
   */
  export type scheduleUpdateArgs = {
    /**
     * Select specific fields to fetch from the schedule
     * 
    **/
    select?: scheduleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: scheduleInclude | null
    /**
     * The data needed to update a schedule.
     * 
    **/
    data: XOR<scheduleUpdateInput, scheduleUncheckedUpdateInput>
    /**
     * Choose, which schedule to update.
     * 
    **/
    where: scheduleWhereUniqueInput
  }


  /**
   * schedule updateMany
   */
  export type scheduleUpdateManyArgs = {
    data: XOR<scheduleUpdateManyMutationInput, scheduleUncheckedUpdateManyInput>
    where?: scheduleWhereInput
  }


  /**
   * schedule upsert
   */
  export type scheduleUpsertArgs = {
    /**
     * Select specific fields to fetch from the schedule
     * 
    **/
    select?: scheduleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: scheduleInclude | null
    /**
     * The filter to search for the schedule to update in case it exists.
     * 
    **/
    where: scheduleWhereUniqueInput
    /**
     * In case the schedule found by the `where` argument doesn't exist, create a new schedule with this data.
     * 
    **/
    create: XOR<scheduleCreateInput, scheduleUncheckedCreateInput>
    /**
     * In case the schedule was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<scheduleUpdateInput, scheduleUncheckedUpdateInput>
  }


  /**
   * schedule delete
   */
  export type scheduleDeleteArgs = {
    /**
     * Select specific fields to fetch from the schedule
     * 
    **/
    select?: scheduleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: scheduleInclude | null
    /**
     * Filter which schedule to delete.
     * 
    **/
    where: scheduleWhereUniqueInput
  }


  /**
   * schedule deleteMany
   */
  export type scheduleDeleteManyArgs = {
    where?: scheduleWhereInput
  }


  /**
   * schedule without action
   */
  export type scheduleArgs = {
    /**
     * Select specific fields to fetch from the schedule
     * 
    **/
    select?: scheduleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: scheduleInclude | null
  }



  /**
   * Model attachement
   */


  export type AggregateAttachement = {
    _count: AttachementCountAggregateOutputType | null
    count: AttachementCountAggregateOutputType | null
    _avg: AttachementAvgAggregateOutputType | null
    avg: AttachementAvgAggregateOutputType | null
    _sum: AttachementSumAggregateOutputType | null
    sum: AttachementSumAggregateOutputType | null
    _min: AttachementMinAggregateOutputType | null
    min: AttachementMinAggregateOutputType | null
    _max: AttachementMaxAggregateOutputType | null
    max: AttachementMaxAggregateOutputType | null
  }

  export type AttachementAvgAggregateOutputType = {
    attachement_id: number | null
  }

  export type AttachementSumAggregateOutputType = {
    attachement_id: number | null
  }

  export type AttachementMinAggregateOutputType = {
    attachement_id: number | null
    Type: string | null
    attachement: string | null
    body: string | null
  }

  export type AttachementMaxAggregateOutputType = {
    attachement_id: number | null
    Type: string | null
    attachement: string | null
    body: string | null
  }

  export type AttachementCountAggregateOutputType = {
    attachement_id: number
    Type: number
    attachement: number
    body: number
    _all: number
  }


  export type AttachementAvgAggregateInputType = {
    attachement_id?: true
  }

  export type AttachementSumAggregateInputType = {
    attachement_id?: true
  }

  export type AttachementMinAggregateInputType = {
    attachement_id?: true
    Type?: true
    attachement?: true
    body?: true
  }

  export type AttachementMaxAggregateInputType = {
    attachement_id?: true
    Type?: true
    attachement?: true
    body?: true
  }

  export type AttachementCountAggregateInputType = {
    attachement_id?: true
    Type?: true
    attachement?: true
    body?: true
    _all?: true
  }

  export type AttachementAggregateArgs = {
    /**
     * Filter which attachement to aggregate.
     * 
    **/
    where?: attachementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of attachements to fetch.
     * 
    **/
    orderBy?: Enumerable<attachementOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: attachementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` attachements from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` attachements.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned attachements
    **/
    _count?: true | AttachementCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | AttachementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AttachementAvgAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_avg`
    **/
    avg?: AttachementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AttachementSumAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_sum`
    **/
    sum?: AttachementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AttachementMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: AttachementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AttachementMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: AttachementMaxAggregateInputType
  }

  export type GetAttachementAggregateType<T extends AttachementAggregateArgs> = {
        [P in keyof T & keyof AggregateAttachement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAttachement[P]>
      : GetScalarType<T[P], AggregateAttachement[P]>
  }


    
    
  export type AttachementGroupByArgs = {
    where?: attachementWhereInput
    orderBy?: Enumerable<attachementOrderByInput>
    by: Array<AttachementScalarFieldEnum>
    having?: attachementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AttachementCountAggregateInputType | true
    _avg?: AttachementAvgAggregateInputType
    _sum?: AttachementSumAggregateInputType
    _min?: AttachementMinAggregateInputType
    _max?: AttachementMaxAggregateInputType
  }


  export type AttachementGroupByOutputType = {
    attachement_id: number
    Type: string
    attachement: string
    body: string
    _count: AttachementCountAggregateOutputType | null
    _avg: AttachementAvgAggregateOutputType | null
    _sum: AttachementSumAggregateOutputType | null
    _min: AttachementMinAggregateOutputType | null
    _max: AttachementMaxAggregateOutputType | null
  }

  type GetAttachementGroupByPayload<T extends AttachementGroupByArgs> = Promise<
    Array<
      PickArray<AttachementGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof AttachementGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], AttachementGroupByOutputType[P]> 
            : GetScalarType<T[P], AttachementGroupByOutputType[P]>
        }
      > 
    >


  export type attachementSelect = {
    attachement_id?: boolean
    Type?: boolean
    attachement?: boolean
    body?: boolean
    free_course?: boolean | free_courseFindManyArgs
  }

  export type attachementInclude = {
    free_course?: boolean | free_courseFindManyArgs
  }

  export type attachementGetPayload<
    S extends boolean | null | undefined | attachementArgs,
    U = keyof S
      > = S extends true
        ? attachement
    : S extends undefined
    ? never
    : S extends attachementArgs | attachementFindManyArgs
    ?'include' extends U
    ? attachement  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'free_course'
        ? Array < free_courseGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof attachement ?attachement [P]
  : 
          P extends 'free_course'
        ? Array < free_courseGetPayload<S['select'][P]>>  : never
  } 
    : attachement
  : attachement


  type attachementCountArgs = Merge<
    Omit<attachementFindManyArgs, 'select' | 'include'> & {
      select?: AttachementCountAggregateInputType | true
    }
  >

  export interface attachementDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Attachement that matches the filter.
     * @param {attachementFindUniqueArgs} args - Arguments to find a Attachement
     * @example
     * // Get one Attachement
     * const attachement = await prisma.attachement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends attachementFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, attachementFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'attachement'> extends True ? CheckSelect<T, Prisma__attachementClient<attachement>, Prisma__attachementClient<attachementGetPayload<T>>> : CheckSelect<T, Prisma__attachementClient<attachement | null >, Prisma__attachementClient<attachementGetPayload<T> | null >>

    /**
     * Find the first Attachement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {attachementFindFirstArgs} args - Arguments to find a Attachement
     * @example
     * // Get one Attachement
     * const attachement = await prisma.attachement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends attachementFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, attachementFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'attachement'> extends True ? CheckSelect<T, Prisma__attachementClient<attachement>, Prisma__attachementClient<attachementGetPayload<T>>> : CheckSelect<T, Prisma__attachementClient<attachement | null >, Prisma__attachementClient<attachementGetPayload<T> | null >>

    /**
     * Find zero or more Attachements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {attachementFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Attachements
     * const attachements = await prisma.attachement.findMany()
     * 
     * // Get first 10 Attachements
     * const attachements = await prisma.attachement.findMany({ take: 10 })
     * 
     * // Only select the `attachement_id`
     * const attachementWithAttachement_idOnly = await prisma.attachement.findMany({ select: { attachement_id: true } })
     * 
    **/
    findMany<T extends attachementFindManyArgs>(
      args?: SelectSubset<T, attachementFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<attachement>>, PrismaPromise<Array<attachementGetPayload<T>>>>

    /**
     * Create a Attachement.
     * @param {attachementCreateArgs} args - Arguments to create a Attachement.
     * @example
     * // Create one Attachement
     * const Attachement = await prisma.attachement.create({
     *   data: {
     *     // ... data to create a Attachement
     *   }
     * })
     * 
    **/
    create<T extends attachementCreateArgs>(
      args: SelectSubset<T, attachementCreateArgs>
    ): CheckSelect<T, Prisma__attachementClient<attachement>, Prisma__attachementClient<attachementGetPayload<T>>>

    /**
     * Create many Attachements.
     *     @param {attachementCreateManyArgs} args - Arguments to create many Attachements.
     *     @example
     *     // Create many Attachements
     *     const attachement = await prisma.attachement.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends attachementCreateManyArgs>(
      args?: SelectSubset<T, attachementCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Attachement.
     * @param {attachementDeleteArgs} args - Arguments to delete one Attachement.
     * @example
     * // Delete one Attachement
     * const Attachement = await prisma.attachement.delete({
     *   where: {
     *     // ... filter to delete one Attachement
     *   }
     * })
     * 
    **/
    delete<T extends attachementDeleteArgs>(
      args: SelectSubset<T, attachementDeleteArgs>
    ): CheckSelect<T, Prisma__attachementClient<attachement>, Prisma__attachementClient<attachementGetPayload<T>>>

    /**
     * Update one Attachement.
     * @param {attachementUpdateArgs} args - Arguments to update one Attachement.
     * @example
     * // Update one Attachement
     * const attachement = await prisma.attachement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends attachementUpdateArgs>(
      args: SelectSubset<T, attachementUpdateArgs>
    ): CheckSelect<T, Prisma__attachementClient<attachement>, Prisma__attachementClient<attachementGetPayload<T>>>

    /**
     * Delete zero or more Attachements.
     * @param {attachementDeleteManyArgs} args - Arguments to filter Attachements to delete.
     * @example
     * // Delete a few Attachements
     * const { count } = await prisma.attachement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends attachementDeleteManyArgs>(
      args?: SelectSubset<T, attachementDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Attachements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {attachementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Attachements
     * const attachement = await prisma.attachement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends attachementUpdateManyArgs>(
      args: SelectSubset<T, attachementUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Attachement.
     * @param {attachementUpsertArgs} args - Arguments to update or create a Attachement.
     * @example
     * // Update or create a Attachement
     * const attachement = await prisma.attachement.upsert({
     *   create: {
     *     // ... data to create a Attachement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Attachement we want to update
     *   }
     * })
    **/
    upsert<T extends attachementUpsertArgs>(
      args: SelectSubset<T, attachementUpsertArgs>
    ): CheckSelect<T, Prisma__attachementClient<attachement>, Prisma__attachementClient<attachementGetPayload<T>>>

    /**
     * Count the number of Attachements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {attachementCountArgs} args - Arguments to filter Attachements to count.
     * @example
     * // Count the number of Attachements
     * const count = await prisma.attachement.count({
     *   where: {
     *     // ... the filter for the Attachements we want to count
     *   }
     * })
    **/
    count<T extends attachementCountArgs>(
      args?: Subset<T, attachementCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AttachementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Attachement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttachementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AttachementAggregateArgs>(args: Subset<T, AttachementAggregateArgs>): PrismaPromise<GetAttachementAggregateType<T>>

    /**
     * Group by Attachement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttachementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AttachementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AttachementGroupByArgs['orderBy'] }
        : { orderBy?: AttachementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AttachementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAttachementGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for attachement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__attachementClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    free_course<T extends free_courseFindManyArgs = {}>(args?: Subset<T, free_courseFindManyArgs>): CheckSelect<T, PrismaPromise<Array<free_course>>, PrismaPromise<Array<free_courseGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * attachement findUnique
   */
  export type attachementFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the attachement
     * 
    **/
    select?: attachementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: attachementInclude | null
    /**
     * Throw an Error if a attachement can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which attachement to fetch.
     * 
    **/
    where: attachementWhereUniqueInput
  }


  /**
   * attachement findFirst
   */
  export type attachementFindFirstArgs = {
    /**
     * Select specific fields to fetch from the attachement
     * 
    **/
    select?: attachementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: attachementInclude | null
    /**
     * Throw an Error if a attachement can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which attachement to fetch.
     * 
    **/
    where?: attachementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of attachements to fetch.
     * 
    **/
    orderBy?: Enumerable<attachementOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for attachements.
     * 
    **/
    cursor?: attachementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` attachements from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` attachements.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of attachements.
     * 
    **/
    distinct?: Enumerable<AttachementScalarFieldEnum>
  }


  /**
   * attachement findMany
   */
  export type attachementFindManyArgs = {
    /**
     * Select specific fields to fetch from the attachement
     * 
    **/
    select?: attachementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: attachementInclude | null
    /**
     * Filter, which attachements to fetch.
     * 
    **/
    where?: attachementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of attachements to fetch.
     * 
    **/
    orderBy?: Enumerable<attachementOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing attachements.
     * 
    **/
    cursor?: attachementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` attachements from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` attachements.
     * 
    **/
    skip?: number
    distinct?: Enumerable<AttachementScalarFieldEnum>
  }


  /**
   * attachement create
   */
  export type attachementCreateArgs = {
    /**
     * Select specific fields to fetch from the attachement
     * 
    **/
    select?: attachementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: attachementInclude | null
    /**
     * The data needed to create a attachement.
     * 
    **/
    data: XOR<attachementCreateInput, attachementUncheckedCreateInput>
  }


  /**
   * attachement createMany
   */
  export type attachementCreateManyArgs = {
    data: Enumerable<attachementCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * attachement update
   */
  export type attachementUpdateArgs = {
    /**
     * Select specific fields to fetch from the attachement
     * 
    **/
    select?: attachementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: attachementInclude | null
    /**
     * The data needed to update a attachement.
     * 
    **/
    data: XOR<attachementUpdateInput, attachementUncheckedUpdateInput>
    /**
     * Choose, which attachement to update.
     * 
    **/
    where: attachementWhereUniqueInput
  }


  /**
   * attachement updateMany
   */
  export type attachementUpdateManyArgs = {
    data: XOR<attachementUpdateManyMutationInput, attachementUncheckedUpdateManyInput>
    where?: attachementWhereInput
  }


  /**
   * attachement upsert
   */
  export type attachementUpsertArgs = {
    /**
     * Select specific fields to fetch from the attachement
     * 
    **/
    select?: attachementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: attachementInclude | null
    /**
     * The filter to search for the attachement to update in case it exists.
     * 
    **/
    where: attachementWhereUniqueInput
    /**
     * In case the attachement found by the `where` argument doesn't exist, create a new attachement with this data.
     * 
    **/
    create: XOR<attachementCreateInput, attachementUncheckedCreateInput>
    /**
     * In case the attachement was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<attachementUpdateInput, attachementUncheckedUpdateInput>
  }


  /**
   * attachement delete
   */
  export type attachementDeleteArgs = {
    /**
     * Select specific fields to fetch from the attachement
     * 
    **/
    select?: attachementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: attachementInclude | null
    /**
     * Filter which attachement to delete.
     * 
    **/
    where: attachementWhereUniqueInput
  }


  /**
   * attachement deleteMany
   */
  export type attachementDeleteManyArgs = {
    where?: attachementWhereInput
  }


  /**
   * attachement without action
   */
  export type attachementArgs = {
    /**
     * Select specific fields to fetch from the attachement
     * 
    **/
    select?: attachementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: attachementInclude | null
  }



  /**
   * Model free_course
   */


  export type AggregateFree_course = {
    _count: Free_courseCountAggregateOutputType | null
    count: Free_courseCountAggregateOutputType | null
    _avg: Free_courseAvgAggregateOutputType | null
    avg: Free_courseAvgAggregateOutputType | null
    _sum: Free_courseSumAggregateOutputType | null
    sum: Free_courseSumAggregateOutputType | null
    _min: Free_courseMinAggregateOutputType | null
    min: Free_courseMinAggregateOutputType | null
    _max: Free_courseMaxAggregateOutputType | null
    max: Free_courseMaxAggregateOutputType | null
  }

  export type Free_courseAvgAggregateOutputType = {
    freeCourse_id: number | null
    teacher: number | null
    document: number | null
  }

  export type Free_courseSumAggregateOutputType = {
    freeCourse_id: number | null
    teacher: number | null
    document: number | null
  }

  export type Free_courseMinAggregateOutputType = {
    freeCourse_id: number | null
    teacher: number | null
    title: string | null
    category: string | null
    Status: string | null
    document: number | null
    image: string | null
  }

  export type Free_courseMaxAggregateOutputType = {
    freeCourse_id: number | null
    teacher: number | null
    title: string | null
    category: string | null
    Status: string | null
    document: number | null
    image: string | null
  }

  export type Free_courseCountAggregateOutputType = {
    freeCourse_id: number
    teacher: number
    title: number
    category: number
    Status: number
    document: number
    image: number
    _all: number
  }


  export type Free_courseAvgAggregateInputType = {
    freeCourse_id?: true
    teacher?: true
    document?: true
  }

  export type Free_courseSumAggregateInputType = {
    freeCourse_id?: true
    teacher?: true
    document?: true
  }

  export type Free_courseMinAggregateInputType = {
    freeCourse_id?: true
    teacher?: true
    title?: true
    category?: true
    Status?: true
    document?: true
    image?: true
  }

  export type Free_courseMaxAggregateInputType = {
    freeCourse_id?: true
    teacher?: true
    title?: true
    category?: true
    Status?: true
    document?: true
    image?: true
  }

  export type Free_courseCountAggregateInputType = {
    freeCourse_id?: true
    teacher?: true
    title?: true
    category?: true
    Status?: true
    document?: true
    image?: true
    _all?: true
  }

  export type Free_courseAggregateArgs = {
    /**
     * Filter which free_course to aggregate.
     * 
    **/
    where?: free_courseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of free_courses to fetch.
     * 
    **/
    orderBy?: Enumerable<free_courseOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: free_courseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` free_courses from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` free_courses.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned free_courses
    **/
    _count?: true | Free_courseCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | Free_courseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Free_courseAvgAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_avg`
    **/
    avg?: Free_courseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Free_courseSumAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_sum`
    **/
    sum?: Free_courseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Free_courseMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: Free_courseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Free_courseMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: Free_courseMaxAggregateInputType
  }

  export type GetFree_courseAggregateType<T extends Free_courseAggregateArgs> = {
        [P in keyof T & keyof AggregateFree_course]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFree_course[P]>
      : GetScalarType<T[P], AggregateFree_course[P]>
  }


    
    
  export type Free_courseGroupByArgs = {
    where?: free_courseWhereInput
    orderBy?: Enumerable<free_courseOrderByInput>
    by: Array<Free_courseScalarFieldEnum>
    having?: free_courseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Free_courseCountAggregateInputType | true
    _avg?: Free_courseAvgAggregateInputType
    _sum?: Free_courseSumAggregateInputType
    _min?: Free_courseMinAggregateInputType
    _max?: Free_courseMaxAggregateInputType
  }


  export type Free_courseGroupByOutputType = {
    freeCourse_id: number
    teacher: number
    title: string
    category: string
    Status: string
    document: number
    image: string
    _count: Free_courseCountAggregateOutputType | null
    _avg: Free_courseAvgAggregateOutputType | null
    _sum: Free_courseSumAggregateOutputType | null
    _min: Free_courseMinAggregateOutputType | null
    _max: Free_courseMaxAggregateOutputType | null
  }

  type GetFree_courseGroupByPayload<T extends Free_courseGroupByArgs> = Promise<
    Array<
      PickArray<Free_courseGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof Free_courseGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], Free_courseGroupByOutputType[P]> 
            : GetScalarType<T[P], Free_courseGroupByOutputType[P]>
        }
      > 
    >


  export type free_courseSelect = {
    freeCourse_id?: boolean
    teacher?: boolean
    title?: boolean
    category?: boolean
    Status?: boolean
    document?: boolean
    image?: boolean
    attachement?: boolean | attachementArgs
    teacher_id?: boolean | teacherArgs
  }

  export type free_courseInclude = {
    attachement?: boolean | attachementArgs
    teacher_id?: boolean | teacherArgs
  }

  export type free_courseGetPayload<
    S extends boolean | null | undefined | free_courseArgs,
    U = keyof S
      > = S extends true
        ? free_course
    : S extends undefined
    ? never
    : S extends free_courseArgs | free_courseFindManyArgs
    ?'include' extends U
    ? free_course  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'attachement'
        ? attachementGetPayload<S['include'][P]> :
        P extends 'teacher_id'
        ? teacherGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof free_course ?free_course [P]
  : 
          P extends 'attachement'
        ? attachementGetPayload<S['select'][P]> :
        P extends 'teacher_id'
        ? teacherGetPayload<S['select'][P]> : never
  } 
    : free_course
  : free_course


  type free_courseCountArgs = Merge<
    Omit<free_courseFindManyArgs, 'select' | 'include'> & {
      select?: Free_courseCountAggregateInputType | true
    }
  >

  export interface free_courseDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Free_course that matches the filter.
     * @param {free_courseFindUniqueArgs} args - Arguments to find a Free_course
     * @example
     * // Get one Free_course
     * const free_course = await prisma.free_course.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends free_courseFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, free_courseFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'free_course'> extends True ? CheckSelect<T, Prisma__free_courseClient<free_course>, Prisma__free_courseClient<free_courseGetPayload<T>>> : CheckSelect<T, Prisma__free_courseClient<free_course | null >, Prisma__free_courseClient<free_courseGetPayload<T> | null >>

    /**
     * Find the first Free_course that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {free_courseFindFirstArgs} args - Arguments to find a Free_course
     * @example
     * // Get one Free_course
     * const free_course = await prisma.free_course.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends free_courseFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, free_courseFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'free_course'> extends True ? CheckSelect<T, Prisma__free_courseClient<free_course>, Prisma__free_courseClient<free_courseGetPayload<T>>> : CheckSelect<T, Prisma__free_courseClient<free_course | null >, Prisma__free_courseClient<free_courseGetPayload<T> | null >>

    /**
     * Find zero or more Free_courses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {free_courseFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Free_courses
     * const free_courses = await prisma.free_course.findMany()
     * 
     * // Get first 10 Free_courses
     * const free_courses = await prisma.free_course.findMany({ take: 10 })
     * 
     * // Only select the `freeCourse_id`
     * const free_courseWithFreeCourse_idOnly = await prisma.free_course.findMany({ select: { freeCourse_id: true } })
     * 
    **/
    findMany<T extends free_courseFindManyArgs>(
      args?: SelectSubset<T, free_courseFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<free_course>>, PrismaPromise<Array<free_courseGetPayload<T>>>>

    /**
     * Create a Free_course.
     * @param {free_courseCreateArgs} args - Arguments to create a Free_course.
     * @example
     * // Create one Free_course
     * const Free_course = await prisma.free_course.create({
     *   data: {
     *     // ... data to create a Free_course
     *   }
     * })
     * 
    **/
    create<T extends free_courseCreateArgs>(
      args: SelectSubset<T, free_courseCreateArgs>
    ): CheckSelect<T, Prisma__free_courseClient<free_course>, Prisma__free_courseClient<free_courseGetPayload<T>>>

    /**
     * Create many Free_courses.
     *     @param {free_courseCreateManyArgs} args - Arguments to create many Free_courses.
     *     @example
     *     // Create many Free_courses
     *     const free_course = await prisma.free_course.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends free_courseCreateManyArgs>(
      args?: SelectSubset<T, free_courseCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Free_course.
     * @param {free_courseDeleteArgs} args - Arguments to delete one Free_course.
     * @example
     * // Delete one Free_course
     * const Free_course = await prisma.free_course.delete({
     *   where: {
     *     // ... filter to delete one Free_course
     *   }
     * })
     * 
    **/
    delete<T extends free_courseDeleteArgs>(
      args: SelectSubset<T, free_courseDeleteArgs>
    ): CheckSelect<T, Prisma__free_courseClient<free_course>, Prisma__free_courseClient<free_courseGetPayload<T>>>

    /**
     * Update one Free_course.
     * @param {free_courseUpdateArgs} args - Arguments to update one Free_course.
     * @example
     * // Update one Free_course
     * const free_course = await prisma.free_course.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends free_courseUpdateArgs>(
      args: SelectSubset<T, free_courseUpdateArgs>
    ): CheckSelect<T, Prisma__free_courseClient<free_course>, Prisma__free_courseClient<free_courseGetPayload<T>>>

    /**
     * Delete zero or more Free_courses.
     * @param {free_courseDeleteManyArgs} args - Arguments to filter Free_courses to delete.
     * @example
     * // Delete a few Free_courses
     * const { count } = await prisma.free_course.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends free_courseDeleteManyArgs>(
      args?: SelectSubset<T, free_courseDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Free_courses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {free_courseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Free_courses
     * const free_course = await prisma.free_course.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends free_courseUpdateManyArgs>(
      args: SelectSubset<T, free_courseUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Free_course.
     * @param {free_courseUpsertArgs} args - Arguments to update or create a Free_course.
     * @example
     * // Update or create a Free_course
     * const free_course = await prisma.free_course.upsert({
     *   create: {
     *     // ... data to create a Free_course
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Free_course we want to update
     *   }
     * })
    **/
    upsert<T extends free_courseUpsertArgs>(
      args: SelectSubset<T, free_courseUpsertArgs>
    ): CheckSelect<T, Prisma__free_courseClient<free_course>, Prisma__free_courseClient<free_courseGetPayload<T>>>

    /**
     * Count the number of Free_courses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {free_courseCountArgs} args - Arguments to filter Free_courses to count.
     * @example
     * // Count the number of Free_courses
     * const count = await prisma.free_course.count({
     *   where: {
     *     // ... the filter for the Free_courses we want to count
     *   }
     * })
    **/
    count<T extends free_courseCountArgs>(
      args?: Subset<T, free_courseCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Free_courseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Free_course.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Free_courseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Free_courseAggregateArgs>(args: Subset<T, Free_courseAggregateArgs>): PrismaPromise<GetFree_courseAggregateType<T>>

    /**
     * Group by Free_course.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Free_courseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Free_courseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Free_courseGroupByArgs['orderBy'] }
        : { orderBy?: Free_courseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Free_courseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFree_courseGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for free_course.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__free_courseClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    attachement<T extends attachementArgs = {}>(args?: Subset<T, attachementArgs>): CheckSelect<T, Prisma__attachementClient<attachement | null >, Prisma__attachementClient<attachementGetPayload<T> | null >>;

    teacher_id<T extends teacherArgs = {}>(args?: Subset<T, teacherArgs>): CheckSelect<T, Prisma__teacherClient<teacher | null >, Prisma__teacherClient<teacherGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * free_course findUnique
   */
  export type free_courseFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the free_course
     * 
    **/
    select?: free_courseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: free_courseInclude | null
    /**
     * Throw an Error if a free_course can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which free_course to fetch.
     * 
    **/
    where: free_courseWhereUniqueInput
  }


  /**
   * free_course findFirst
   */
  export type free_courseFindFirstArgs = {
    /**
     * Select specific fields to fetch from the free_course
     * 
    **/
    select?: free_courseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: free_courseInclude | null
    /**
     * Throw an Error if a free_course can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which free_course to fetch.
     * 
    **/
    where?: free_courseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of free_courses to fetch.
     * 
    **/
    orderBy?: Enumerable<free_courseOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for free_courses.
     * 
    **/
    cursor?: free_courseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` free_courses from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` free_courses.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of free_courses.
     * 
    **/
    distinct?: Enumerable<Free_courseScalarFieldEnum>
  }


  /**
   * free_course findMany
   */
  export type free_courseFindManyArgs = {
    /**
     * Select specific fields to fetch from the free_course
     * 
    **/
    select?: free_courseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: free_courseInclude | null
    /**
     * Filter, which free_courses to fetch.
     * 
    **/
    where?: free_courseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of free_courses to fetch.
     * 
    **/
    orderBy?: Enumerable<free_courseOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing free_courses.
     * 
    **/
    cursor?: free_courseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` free_courses from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` free_courses.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Free_courseScalarFieldEnum>
  }


  /**
   * free_course create
   */
  export type free_courseCreateArgs = {
    /**
     * Select specific fields to fetch from the free_course
     * 
    **/
    select?: free_courseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: free_courseInclude | null
    /**
     * The data needed to create a free_course.
     * 
    **/
    data: XOR<free_courseCreateInput, free_courseUncheckedCreateInput>
  }


  /**
   * free_course createMany
   */
  export type free_courseCreateManyArgs = {
    data: Enumerable<free_courseCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * free_course update
   */
  export type free_courseUpdateArgs = {
    /**
     * Select specific fields to fetch from the free_course
     * 
    **/
    select?: free_courseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: free_courseInclude | null
    /**
     * The data needed to update a free_course.
     * 
    **/
    data: XOR<free_courseUpdateInput, free_courseUncheckedUpdateInput>
    /**
     * Choose, which free_course to update.
     * 
    **/
    where: free_courseWhereUniqueInput
  }


  /**
   * free_course updateMany
   */
  export type free_courseUpdateManyArgs = {
    data: XOR<free_courseUpdateManyMutationInput, free_courseUncheckedUpdateManyInput>
    where?: free_courseWhereInput
  }


  /**
   * free_course upsert
   */
  export type free_courseUpsertArgs = {
    /**
     * Select specific fields to fetch from the free_course
     * 
    **/
    select?: free_courseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: free_courseInclude | null
    /**
     * The filter to search for the free_course to update in case it exists.
     * 
    **/
    where: free_courseWhereUniqueInput
    /**
     * In case the free_course found by the `where` argument doesn't exist, create a new free_course with this data.
     * 
    **/
    create: XOR<free_courseCreateInput, free_courseUncheckedCreateInput>
    /**
     * In case the free_course was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<free_courseUpdateInput, free_courseUncheckedUpdateInput>
  }


  /**
   * free_course delete
   */
  export type free_courseDeleteArgs = {
    /**
     * Select specific fields to fetch from the free_course
     * 
    **/
    select?: free_courseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: free_courseInclude | null
    /**
     * Filter which free_course to delete.
     * 
    **/
    where: free_courseWhereUniqueInput
  }


  /**
   * free_course deleteMany
   */
  export type free_courseDeleteManyArgs = {
    where?: free_courseWhereInput
  }


  /**
   * free_course without action
   */
  export type free_courseArgs = {
    /**
     * Select specific fields to fetch from the free_course
     * 
    **/
    select?: free_courseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: free_courseInclude | null
  }



  /**
   * Model feedback
   */


  export type AggregateFeedback = {
    _count: FeedbackCountAggregateOutputType | null
    count: FeedbackCountAggregateOutputType | null
    _avg: FeedbackAvgAggregateOutputType | null
    avg: FeedbackAvgAggregateOutputType | null
    _sum: FeedbackSumAggregateOutputType | null
    sum: FeedbackSumAggregateOutputType | null
    _min: FeedbackMinAggregateOutputType | null
    min: FeedbackMinAggregateOutputType | null
    _max: FeedbackMaxAggregateOutputType | null
    max: FeedbackMaxAggregateOutputType | null
  }

  export type FeedbackAvgAggregateOutputType = {
    feedback_id: number | null
    student: number | null
    stars: number | null
  }

  export type FeedbackSumAggregateOutputType = {
    feedback_id: number | null
    student: number | null
    stars: number | null
  }

  export type FeedbackMinAggregateOutputType = {
    feedback_id: number | null
    student: number | null
    stars: number | null
    comment: string | null
  }

  export type FeedbackMaxAggregateOutputType = {
    feedback_id: number | null
    student: number | null
    stars: number | null
    comment: string | null
  }

  export type FeedbackCountAggregateOutputType = {
    feedback_id: number
    student: number
    stars: number
    comment: number
    _all: number
  }


  export type FeedbackAvgAggregateInputType = {
    feedback_id?: true
    student?: true
    stars?: true
  }

  export type FeedbackSumAggregateInputType = {
    feedback_id?: true
    student?: true
    stars?: true
  }

  export type FeedbackMinAggregateInputType = {
    feedback_id?: true
    student?: true
    stars?: true
    comment?: true
  }

  export type FeedbackMaxAggregateInputType = {
    feedback_id?: true
    student?: true
    stars?: true
    comment?: true
  }

  export type FeedbackCountAggregateInputType = {
    feedback_id?: true
    student?: true
    stars?: true
    comment?: true
    _all?: true
  }

  export type FeedbackAggregateArgs = {
    /**
     * Filter which feedback to aggregate.
     * 
    **/
    where?: feedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of feedbacks to fetch.
     * 
    **/
    orderBy?: Enumerable<feedbackOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: feedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` feedbacks from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` feedbacks.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned feedbacks
    **/
    _count?: true | FeedbackCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | FeedbackCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FeedbackAvgAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_avg`
    **/
    avg?: FeedbackAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FeedbackSumAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_sum`
    **/
    sum?: FeedbackSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FeedbackMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: FeedbackMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FeedbackMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: FeedbackMaxAggregateInputType
  }

  export type GetFeedbackAggregateType<T extends FeedbackAggregateArgs> = {
        [P in keyof T & keyof AggregateFeedback]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFeedback[P]>
      : GetScalarType<T[P], AggregateFeedback[P]>
  }


    
    
  export type FeedbackGroupByArgs = {
    where?: feedbackWhereInput
    orderBy?: Enumerable<feedbackOrderByInput>
    by: Array<FeedbackScalarFieldEnum>
    having?: feedbackScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FeedbackCountAggregateInputType | true
    _avg?: FeedbackAvgAggregateInputType
    _sum?: FeedbackSumAggregateInputType
    _min?: FeedbackMinAggregateInputType
    _max?: FeedbackMaxAggregateInputType
  }


  export type FeedbackGroupByOutputType = {
    feedback_id: number
    student: number
    stars: number
    comment: string
    _count: FeedbackCountAggregateOutputType | null
    _avg: FeedbackAvgAggregateOutputType | null
    _sum: FeedbackSumAggregateOutputType | null
    _min: FeedbackMinAggregateOutputType | null
    _max: FeedbackMaxAggregateOutputType | null
  }

  type GetFeedbackGroupByPayload<T extends FeedbackGroupByArgs> = Promise<
    Array<
      PickArray<FeedbackGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof FeedbackGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], FeedbackGroupByOutputType[P]> 
            : GetScalarType<T[P], FeedbackGroupByOutputType[P]>
        }
      > 
    >


  export type feedbackSelect = {
    feedback_id?: boolean
    student?: boolean
    stars?: boolean
    comment?: boolean
    student_id?: boolean | studentArgs
  }

  export type feedbackInclude = {
    student_id?: boolean | studentArgs
  }

  export type feedbackGetPayload<
    S extends boolean | null | undefined | feedbackArgs,
    U = keyof S
      > = S extends true
        ? feedback
    : S extends undefined
    ? never
    : S extends feedbackArgs | feedbackFindManyArgs
    ?'include' extends U
    ? feedback  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'student_id'
        ? studentGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof feedback ?feedback [P]
  : 
          P extends 'student_id'
        ? studentGetPayload<S['select'][P]> : never
  } 
    : feedback
  : feedback


  type feedbackCountArgs = Merge<
    Omit<feedbackFindManyArgs, 'select' | 'include'> & {
      select?: FeedbackCountAggregateInputType | true
    }
  >

  export interface feedbackDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Feedback that matches the filter.
     * @param {feedbackFindUniqueArgs} args - Arguments to find a Feedback
     * @example
     * // Get one Feedback
     * const feedback = await prisma.feedback.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends feedbackFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, feedbackFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'feedback'> extends True ? CheckSelect<T, Prisma__feedbackClient<feedback>, Prisma__feedbackClient<feedbackGetPayload<T>>> : CheckSelect<T, Prisma__feedbackClient<feedback | null >, Prisma__feedbackClient<feedbackGetPayload<T> | null >>

    /**
     * Find the first Feedback that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {feedbackFindFirstArgs} args - Arguments to find a Feedback
     * @example
     * // Get one Feedback
     * const feedback = await prisma.feedback.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends feedbackFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, feedbackFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'feedback'> extends True ? CheckSelect<T, Prisma__feedbackClient<feedback>, Prisma__feedbackClient<feedbackGetPayload<T>>> : CheckSelect<T, Prisma__feedbackClient<feedback | null >, Prisma__feedbackClient<feedbackGetPayload<T> | null >>

    /**
     * Find zero or more Feedbacks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {feedbackFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Feedbacks
     * const feedbacks = await prisma.feedback.findMany()
     * 
     * // Get first 10 Feedbacks
     * const feedbacks = await prisma.feedback.findMany({ take: 10 })
     * 
     * // Only select the `feedback_id`
     * const feedbackWithFeedback_idOnly = await prisma.feedback.findMany({ select: { feedback_id: true } })
     * 
    **/
    findMany<T extends feedbackFindManyArgs>(
      args?: SelectSubset<T, feedbackFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<feedback>>, PrismaPromise<Array<feedbackGetPayload<T>>>>

    /**
     * Create a Feedback.
     * @param {feedbackCreateArgs} args - Arguments to create a Feedback.
     * @example
     * // Create one Feedback
     * const Feedback = await prisma.feedback.create({
     *   data: {
     *     // ... data to create a Feedback
     *   }
     * })
     * 
    **/
    create<T extends feedbackCreateArgs>(
      args: SelectSubset<T, feedbackCreateArgs>
    ): CheckSelect<T, Prisma__feedbackClient<feedback>, Prisma__feedbackClient<feedbackGetPayload<T>>>

    /**
     * Create many Feedbacks.
     *     @param {feedbackCreateManyArgs} args - Arguments to create many Feedbacks.
     *     @example
     *     // Create many Feedbacks
     *     const feedback = await prisma.feedback.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends feedbackCreateManyArgs>(
      args?: SelectSubset<T, feedbackCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Feedback.
     * @param {feedbackDeleteArgs} args - Arguments to delete one Feedback.
     * @example
     * // Delete one Feedback
     * const Feedback = await prisma.feedback.delete({
     *   where: {
     *     // ... filter to delete one Feedback
     *   }
     * })
     * 
    **/
    delete<T extends feedbackDeleteArgs>(
      args: SelectSubset<T, feedbackDeleteArgs>
    ): CheckSelect<T, Prisma__feedbackClient<feedback>, Prisma__feedbackClient<feedbackGetPayload<T>>>

    /**
     * Update one Feedback.
     * @param {feedbackUpdateArgs} args - Arguments to update one Feedback.
     * @example
     * // Update one Feedback
     * const feedback = await prisma.feedback.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends feedbackUpdateArgs>(
      args: SelectSubset<T, feedbackUpdateArgs>
    ): CheckSelect<T, Prisma__feedbackClient<feedback>, Prisma__feedbackClient<feedbackGetPayload<T>>>

    /**
     * Delete zero or more Feedbacks.
     * @param {feedbackDeleteManyArgs} args - Arguments to filter Feedbacks to delete.
     * @example
     * // Delete a few Feedbacks
     * const { count } = await prisma.feedback.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends feedbackDeleteManyArgs>(
      args?: SelectSubset<T, feedbackDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Feedbacks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {feedbackUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Feedbacks
     * const feedback = await prisma.feedback.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends feedbackUpdateManyArgs>(
      args: SelectSubset<T, feedbackUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Feedback.
     * @param {feedbackUpsertArgs} args - Arguments to update or create a Feedback.
     * @example
     * // Update or create a Feedback
     * const feedback = await prisma.feedback.upsert({
     *   create: {
     *     // ... data to create a Feedback
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Feedback we want to update
     *   }
     * })
    **/
    upsert<T extends feedbackUpsertArgs>(
      args: SelectSubset<T, feedbackUpsertArgs>
    ): CheckSelect<T, Prisma__feedbackClient<feedback>, Prisma__feedbackClient<feedbackGetPayload<T>>>

    /**
     * Count the number of Feedbacks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {feedbackCountArgs} args - Arguments to filter Feedbacks to count.
     * @example
     * // Count the number of Feedbacks
     * const count = await prisma.feedback.count({
     *   where: {
     *     // ... the filter for the Feedbacks we want to count
     *   }
     * })
    **/
    count<T extends feedbackCountArgs>(
      args?: Subset<T, feedbackCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FeedbackCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Feedback.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FeedbackAggregateArgs>(args: Subset<T, FeedbackAggregateArgs>): PrismaPromise<GetFeedbackAggregateType<T>>

    /**
     * Group by Feedback.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FeedbackGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FeedbackGroupByArgs['orderBy'] }
        : { orderBy?: FeedbackGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FeedbackGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFeedbackGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for feedback.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__feedbackClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    student_id<T extends studentArgs = {}>(args?: Subset<T, studentArgs>): CheckSelect<T, Prisma__studentClient<student | null >, Prisma__studentClient<studentGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * feedback findUnique
   */
  export type feedbackFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the feedback
     * 
    **/
    select?: feedbackSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: feedbackInclude | null
    /**
     * Throw an Error if a feedback can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which feedback to fetch.
     * 
    **/
    where: feedbackWhereUniqueInput
  }


  /**
   * feedback findFirst
   */
  export type feedbackFindFirstArgs = {
    /**
     * Select specific fields to fetch from the feedback
     * 
    **/
    select?: feedbackSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: feedbackInclude | null
    /**
     * Throw an Error if a feedback can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which feedback to fetch.
     * 
    **/
    where?: feedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of feedbacks to fetch.
     * 
    **/
    orderBy?: Enumerable<feedbackOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for feedbacks.
     * 
    **/
    cursor?: feedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` feedbacks from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` feedbacks.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of feedbacks.
     * 
    **/
    distinct?: Enumerable<FeedbackScalarFieldEnum>
  }


  /**
   * feedback findMany
   */
  export type feedbackFindManyArgs = {
    /**
     * Select specific fields to fetch from the feedback
     * 
    **/
    select?: feedbackSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: feedbackInclude | null
    /**
     * Filter, which feedbacks to fetch.
     * 
    **/
    where?: feedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of feedbacks to fetch.
     * 
    **/
    orderBy?: Enumerable<feedbackOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing feedbacks.
     * 
    **/
    cursor?: feedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` feedbacks from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` feedbacks.
     * 
    **/
    skip?: number
    distinct?: Enumerable<FeedbackScalarFieldEnum>
  }


  /**
   * feedback create
   */
  export type feedbackCreateArgs = {
    /**
     * Select specific fields to fetch from the feedback
     * 
    **/
    select?: feedbackSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: feedbackInclude | null
    /**
     * The data needed to create a feedback.
     * 
    **/
    data: XOR<feedbackCreateInput, feedbackUncheckedCreateInput>
  }


  /**
   * feedback createMany
   */
  export type feedbackCreateManyArgs = {
    data: Enumerable<feedbackCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * feedback update
   */
  export type feedbackUpdateArgs = {
    /**
     * Select specific fields to fetch from the feedback
     * 
    **/
    select?: feedbackSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: feedbackInclude | null
    /**
     * The data needed to update a feedback.
     * 
    **/
    data: XOR<feedbackUpdateInput, feedbackUncheckedUpdateInput>
    /**
     * Choose, which feedback to update.
     * 
    **/
    where: feedbackWhereUniqueInput
  }


  /**
   * feedback updateMany
   */
  export type feedbackUpdateManyArgs = {
    data: XOR<feedbackUpdateManyMutationInput, feedbackUncheckedUpdateManyInput>
    where?: feedbackWhereInput
  }


  /**
   * feedback upsert
   */
  export type feedbackUpsertArgs = {
    /**
     * Select specific fields to fetch from the feedback
     * 
    **/
    select?: feedbackSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: feedbackInclude | null
    /**
     * The filter to search for the feedback to update in case it exists.
     * 
    **/
    where: feedbackWhereUniqueInput
    /**
     * In case the feedback found by the `where` argument doesn't exist, create a new feedback with this data.
     * 
    **/
    create: XOR<feedbackCreateInput, feedbackUncheckedCreateInput>
    /**
     * In case the feedback was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<feedbackUpdateInput, feedbackUncheckedUpdateInput>
  }


  /**
   * feedback delete
   */
  export type feedbackDeleteArgs = {
    /**
     * Select specific fields to fetch from the feedback
     * 
    **/
    select?: feedbackSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: feedbackInclude | null
    /**
     * Filter which feedback to delete.
     * 
    **/
    where: feedbackWhereUniqueInput
  }


  /**
   * feedback deleteMany
   */
  export type feedbackDeleteManyArgs = {
    where?: feedbackWhereInput
  }


  /**
   * feedback without action
   */
  export type feedbackArgs = {
    /**
     * Select specific fields to fetch from the feedback
     * 
    **/
    select?: feedbackSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: feedbackInclude | null
  }



  /**
   * Enums
   */

  // Based on
  // https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

  export const StudentScalarFieldEnum: {
    student_id: 'student_id',
    userName: 'userName',
    password: 'password',
    education: 'education',
    age: 'age',
    wallet: 'wallet',
    image: 'image',
    email: 'email',
    token: 'token'
  };

  export type StudentScalarFieldEnum = (typeof StudentScalarFieldEnum)[keyof typeof StudentScalarFieldEnum]


  export const TeacherScalarFieldEnum: {
    teacher_id: 'teacher_id',
    sumOfRates: 'sumOfRates',
    email: 'email',
    userName: 'userName',
    password: 'password',
    education: 'education',
    description: 'description',
    age: 'age',
    wallet: 'wallet',
    image: 'image',
    token: 'token',
    Overall_rating: 'Overall_rating',
    numberOfRates: 'numberOfRates'
  };

  export type TeacherScalarFieldEnum = (typeof TeacherScalarFieldEnum)[keyof typeof TeacherScalarFieldEnum]


  export const WeekDayScalarFieldEnum: {
    weekDay_id: 'weekDay_id',
    teacher_id: 'teacher_id',
    monday: 'monday',
    tuesday: 'tuesday',
    wednesday: 'wednesday',
    thursday: 'thursday',
    friday: 'friday',
    saturday: 'saturday',
    sunday: 'sunday'
  };

  export type WeekDayScalarFieldEnum = (typeof WeekDayScalarFieldEnum)[keyof typeof WeekDayScalarFieldEnum]


  export const SessionsScalarFieldEnum: {
    sessions_id: 'sessions_id',
    teacher_id: 'teacher_id',
    one: 'one',
    two: 'two',
    three: 'three',
    four: 'four',
    five: 'five',
    six: 'six'
  };

  export type SessionsScalarFieldEnum = (typeof SessionsScalarFieldEnum)[keyof typeof SessionsScalarFieldEnum]


  export const PostScalarFieldEnum: {
    post_id: 'post_id',
    author_id: 'author_id',
    Image: 'Image',
    status: 'status',
    body: 'body',
    title: 'title',
    price: 'price'
  };

  export type PostScalarFieldEnum = (typeof PostScalarFieldEnum)[keyof typeof PostScalarFieldEnum]


  export const ReviewScalarFieldEnum: {
    review_id: 'review_id',
    overallRating: 'overallRating',
    ratesNumber: 'ratesNumber',
    student_id: 'student_id',
    teacher_id: 'teacher_id',
    comments: 'comments'
  };

  export type ReviewScalarFieldEnum = (typeof ReviewScalarFieldEnum)[keyof typeof ReviewScalarFieldEnum]


  export const ScheduleScalarFieldEnum: {
    scheduel_id: 'scheduel_id',
    student: 'student',
    teacher: 'teacher',
    day: 'day',
    session: 'session'
  };

  export type ScheduleScalarFieldEnum = (typeof ScheduleScalarFieldEnum)[keyof typeof ScheduleScalarFieldEnum]


  export const AttachementScalarFieldEnum: {
    attachement_id: 'attachement_id',
    Type: 'Type',
    attachement: 'attachement',
    body: 'body'
  };

  export type AttachementScalarFieldEnum = (typeof AttachementScalarFieldEnum)[keyof typeof AttachementScalarFieldEnum]


  export const Free_courseScalarFieldEnum: {
    freeCourse_id: 'freeCourse_id',
    teacher: 'teacher',
    title: 'title',
    category: 'category',
    Status: 'Status',
    document: 'document',
    image: 'image'
  };

  export type Free_courseScalarFieldEnum = (typeof Free_courseScalarFieldEnum)[keyof typeof Free_courseScalarFieldEnum]


  export const FeedbackScalarFieldEnum: {
    feedback_id: 'feedback_id',
    student: 'student',
    stars: 'stars',
    comment: 'comment'
  };

  export type FeedbackScalarFieldEnum = (typeof FeedbackScalarFieldEnum)[keyof typeof FeedbackScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  /**
   * Deep Input Types
   */


  export type studentWhereInput = {
    AND?: Enumerable<studentWhereInput>
    OR?: Enumerable<studentWhereInput>
    NOT?: Enumerable<studentWhereInput>
    student_id?: IntFilter | number
    userName?: StringFilter | string
    password?: StringFilter | string
    education?: StringFilter | string
    age?: IntFilter | number
    wallet?: IntFilter | number
    image?: StringFilter | string
    email?: StringFilter | string
    token?: StringFilter | string
    DM?: FeedbackListRelationFilter
    review?: ReviewListRelationFilter
    schedule?: ScheduleListRelationFilter
  }

  export type studentOrderByInput = {
    student_id?: SortOrder
    userName?: SortOrder
    password?: SortOrder
    education?: SortOrder
    age?: SortOrder
    wallet?: SortOrder
    image?: SortOrder
    email?: SortOrder
    token?: SortOrder
  }

  export type studentWhereUniqueInput = {
    student_id?: number
    email?: string
    token?: string
  }

  export type studentScalarWhereWithAggregatesInput = {
    AND?: Enumerable<studentScalarWhereWithAggregatesInput>
    OR?: Enumerable<studentScalarWhereWithAggregatesInput>
    NOT?: Enumerable<studentScalarWhereWithAggregatesInput>
    student_id?: IntWithAggregatesFilter | number
    userName?: StringWithAggregatesFilter | string
    password?: StringWithAggregatesFilter | string
    education?: StringWithAggregatesFilter | string
    age?: IntWithAggregatesFilter | number
    wallet?: IntWithAggregatesFilter | number
    image?: StringWithAggregatesFilter | string
    email?: StringWithAggregatesFilter | string
    token?: StringWithAggregatesFilter | string
  }

  export type teacherWhereInput = {
    AND?: Enumerable<teacherWhereInput>
    OR?: Enumerable<teacherWhereInput>
    NOT?: Enumerable<teacherWhereInput>
    teacher_id?: IntFilter | number
    sumOfRates?: IntFilter | number
    email?: StringFilter | string
    userName?: StringFilter | string
    password?: StringFilter | string
    education?: StringFilter | string
    description?: StringFilter | string
    age?: IntFilter | number
    wallet?: IntFilter | number
    image?: StringFilter | string
    token?: StringFilter | string
    Overall_rating?: IntFilter | number
    numberOfRates?: IntFilter | number
    free_course?: Free_courseListRelationFilter
    post?: PostListRelationFilter
    review?: ReviewListRelationFilter
    schedule?: ScheduleListRelationFilter
    sessions?: XOR<SessionsRelationFilter, sessionsWhereInput> | null
    weekDay?: XOR<WeekDayRelationFilter, weekDayWhereInput> | null
  }

  export type teacherOrderByInput = {
    teacher_id?: SortOrder
    sumOfRates?: SortOrder
    email?: SortOrder
    userName?: SortOrder
    password?: SortOrder
    education?: SortOrder
    description?: SortOrder
    age?: SortOrder
    wallet?: SortOrder
    image?: SortOrder
    token?: SortOrder
    Overall_rating?: SortOrder
    numberOfRates?: SortOrder
  }

  export type teacherWhereUniqueInput = {
    teacher_id?: number
    email?: string
    token?: string
  }

  export type teacherScalarWhereWithAggregatesInput = {
    AND?: Enumerable<teacherScalarWhereWithAggregatesInput>
    OR?: Enumerable<teacherScalarWhereWithAggregatesInput>
    NOT?: Enumerable<teacherScalarWhereWithAggregatesInput>
    teacher_id?: IntWithAggregatesFilter | number
    sumOfRates?: IntWithAggregatesFilter | number
    email?: StringWithAggregatesFilter | string
    userName?: StringWithAggregatesFilter | string
    password?: StringWithAggregatesFilter | string
    education?: StringWithAggregatesFilter | string
    description?: StringWithAggregatesFilter | string
    age?: IntWithAggregatesFilter | number
    wallet?: IntWithAggregatesFilter | number
    image?: StringWithAggregatesFilter | string
    token?: StringWithAggregatesFilter | string
    Overall_rating?: IntWithAggregatesFilter | number
    numberOfRates?: IntWithAggregatesFilter | number
  }

  export type weekDayWhereInput = {
    AND?: Enumerable<weekDayWhereInput>
    OR?: Enumerable<weekDayWhereInput>
    NOT?: Enumerable<weekDayWhereInput>
    weekDay_id?: IntFilter | number
    teacher_id?: IntFilter | number
    monday?: BoolFilter | boolean
    tuesday?: BoolFilter | boolean
    wednesday?: BoolFilter | boolean
    thursday?: BoolFilter | boolean
    friday?: BoolFilter | boolean
    saturday?: BoolFilter | boolean
    sunday?: BoolFilter | boolean
    teacher?: XOR<TeacherRelationFilter, teacherWhereInput>
  }

  export type weekDayOrderByInput = {
    weekDay_id?: SortOrder
    teacher_id?: SortOrder
    monday?: SortOrder
    tuesday?: SortOrder
    wednesday?: SortOrder
    thursday?: SortOrder
    friday?: SortOrder
    saturday?: SortOrder
    sunday?: SortOrder
  }

  export type weekDayWhereUniqueInput = {
    weekDay_id?: number
    teacher_id?: number
  }

  export type weekDayScalarWhereWithAggregatesInput = {
    AND?: Enumerable<weekDayScalarWhereWithAggregatesInput>
    OR?: Enumerable<weekDayScalarWhereWithAggregatesInput>
    NOT?: Enumerable<weekDayScalarWhereWithAggregatesInput>
    weekDay_id?: IntWithAggregatesFilter | number
    teacher_id?: IntWithAggregatesFilter | number
    monday?: BoolWithAggregatesFilter | boolean
    tuesday?: BoolWithAggregatesFilter | boolean
    wednesday?: BoolWithAggregatesFilter | boolean
    thursday?: BoolWithAggregatesFilter | boolean
    friday?: BoolWithAggregatesFilter | boolean
    saturday?: BoolWithAggregatesFilter | boolean
    sunday?: BoolWithAggregatesFilter | boolean
  }

  export type sessionsWhereInput = {
    AND?: Enumerable<sessionsWhereInput>
    OR?: Enumerable<sessionsWhereInput>
    NOT?: Enumerable<sessionsWhereInput>
    sessions_id?: IntFilter | number
    teacher_id?: IntFilter | number
    one?: BoolFilter | boolean
    two?: BoolFilter | boolean
    three?: BoolFilter | boolean
    four?: BoolFilter | boolean
    five?: BoolFilter | boolean
    six?: BoolFilter | boolean
    teacher?: XOR<TeacherRelationFilter, teacherWhereInput>
  }

  export type sessionsOrderByInput = {
    sessions_id?: SortOrder
    teacher_id?: SortOrder
    one?: SortOrder
    two?: SortOrder
    three?: SortOrder
    four?: SortOrder
    five?: SortOrder
    six?: SortOrder
  }

  export type sessionsWhereUniqueInput = {
    sessions_id?: number
    teacher_id?: number
  }

  export type sessionsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<sessionsScalarWhereWithAggregatesInput>
    OR?: Enumerable<sessionsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<sessionsScalarWhereWithAggregatesInput>
    sessions_id?: IntWithAggregatesFilter | number
    teacher_id?: IntWithAggregatesFilter | number
    one?: BoolWithAggregatesFilter | boolean
    two?: BoolWithAggregatesFilter | boolean
    three?: BoolWithAggregatesFilter | boolean
    four?: BoolWithAggregatesFilter | boolean
    five?: BoolWithAggregatesFilter | boolean
    six?: BoolWithAggregatesFilter | boolean
  }

  export type postWhereInput = {
    AND?: Enumerable<postWhereInput>
    OR?: Enumerable<postWhereInput>
    NOT?: Enumerable<postWhereInput>
    post_id?: IntFilter | number
    author_id?: IntFilter | number
    Image?: StringFilter | string
    status?: StringFilter | string
    body?: StringFilter | string
    title?: StringFilter | string
    price?: IntFilter | number
    author?: XOR<TeacherRelationFilter, teacherWhereInput>
  }

  export type postOrderByInput = {
    post_id?: SortOrder
    author_id?: SortOrder
    Image?: SortOrder
    status?: SortOrder
    body?: SortOrder
    title?: SortOrder
    price?: SortOrder
  }

  export type postWhereUniqueInput = {
    post_id?: number
  }

  export type postScalarWhereWithAggregatesInput = {
    AND?: Enumerable<postScalarWhereWithAggregatesInput>
    OR?: Enumerable<postScalarWhereWithAggregatesInput>
    NOT?: Enumerable<postScalarWhereWithAggregatesInput>
    post_id?: IntWithAggregatesFilter | number
    author_id?: IntWithAggregatesFilter | number
    Image?: StringWithAggregatesFilter | string
    status?: StringWithAggregatesFilter | string
    body?: StringWithAggregatesFilter | string
    title?: StringWithAggregatesFilter | string
    price?: IntWithAggregatesFilter | number
  }

  export type reviewWhereInput = {
    AND?: Enumerable<reviewWhereInput>
    OR?: Enumerable<reviewWhereInput>
    NOT?: Enumerable<reviewWhereInput>
    review_id?: IntFilter | number
    overallRating?: IntFilter | number
    ratesNumber?: IntFilter | number
    student_id?: IntFilter | number
    teacher_id?: IntFilter | number
    comments?: StringFilter | string
    student?: XOR<StudentRelationFilter, studentWhereInput>
    teacher?: XOR<TeacherRelationFilter, teacherWhereInput>
  }

  export type reviewOrderByInput = {
    review_id?: SortOrder
    overallRating?: SortOrder
    ratesNumber?: SortOrder
    student_id?: SortOrder
    teacher_id?: SortOrder
    comments?: SortOrder
  }

  export type reviewWhereUniqueInput = {
    review_id?: number
  }

  export type reviewScalarWhereWithAggregatesInput = {
    AND?: Enumerable<reviewScalarWhereWithAggregatesInput>
    OR?: Enumerable<reviewScalarWhereWithAggregatesInput>
    NOT?: Enumerable<reviewScalarWhereWithAggregatesInput>
    review_id?: IntWithAggregatesFilter | number
    overallRating?: IntWithAggregatesFilter | number
    ratesNumber?: IntWithAggregatesFilter | number
    student_id?: IntWithAggregatesFilter | number
    teacher_id?: IntWithAggregatesFilter | number
    comments?: StringWithAggregatesFilter | string
  }

  export type scheduleWhereInput = {
    AND?: Enumerable<scheduleWhereInput>
    OR?: Enumerable<scheduleWhereInput>
    NOT?: Enumerable<scheduleWhereInput>
    scheduel_id?: IntFilter | number
    student?: IntFilter | number
    teacher?: IntFilter | number
    day?: StringFilter | string
    session?: StringFilter | string
    student_id?: XOR<StudentRelationFilter, studentWhereInput>
    teacher_id?: XOR<TeacherRelationFilter, teacherWhereInput>
  }

  export type scheduleOrderByInput = {
    scheduel_id?: SortOrder
    student?: SortOrder
    teacher?: SortOrder
    day?: SortOrder
    session?: SortOrder
  }

  export type scheduleWhereUniqueInput = {
    scheduel_id?: number
  }

  export type scheduleScalarWhereWithAggregatesInput = {
    AND?: Enumerable<scheduleScalarWhereWithAggregatesInput>
    OR?: Enumerable<scheduleScalarWhereWithAggregatesInput>
    NOT?: Enumerable<scheduleScalarWhereWithAggregatesInput>
    scheduel_id?: IntWithAggregatesFilter | number
    student?: IntWithAggregatesFilter | number
    teacher?: IntWithAggregatesFilter | number
    day?: StringWithAggregatesFilter | string
    session?: StringWithAggregatesFilter | string
  }

  export type attachementWhereInput = {
    AND?: Enumerable<attachementWhereInput>
    OR?: Enumerable<attachementWhereInput>
    NOT?: Enumerable<attachementWhereInput>
    attachement_id?: IntFilter | number
    Type?: StringFilter | string
    attachement?: StringFilter | string
    body?: StringFilter | string
    free_course?: Free_courseListRelationFilter
  }

  export type attachementOrderByInput = {
    attachement_id?: SortOrder
    Type?: SortOrder
    attachement?: SortOrder
    body?: SortOrder
  }

  export type attachementWhereUniqueInput = {
    attachement_id?: number
  }

  export type attachementScalarWhereWithAggregatesInput = {
    AND?: Enumerable<attachementScalarWhereWithAggregatesInput>
    OR?: Enumerable<attachementScalarWhereWithAggregatesInput>
    NOT?: Enumerable<attachementScalarWhereWithAggregatesInput>
    attachement_id?: IntWithAggregatesFilter | number
    Type?: StringWithAggregatesFilter | string
    attachement?: StringWithAggregatesFilter | string
    body?: StringWithAggregatesFilter | string
  }

  export type free_courseWhereInput = {
    AND?: Enumerable<free_courseWhereInput>
    OR?: Enumerable<free_courseWhereInput>
    NOT?: Enumerable<free_courseWhereInput>
    freeCourse_id?: IntFilter | number
    teacher?: IntFilter | number
    title?: StringFilter | string
    category?: StringFilter | string
    Status?: StringFilter | string
    document?: IntFilter | number
    image?: StringFilter | string
    attachement?: XOR<AttachementRelationFilter, attachementWhereInput>
    teacher_id?: XOR<TeacherRelationFilter, teacherWhereInput>
  }

  export type free_courseOrderByInput = {
    freeCourse_id?: SortOrder
    teacher?: SortOrder
    title?: SortOrder
    category?: SortOrder
    Status?: SortOrder
    document?: SortOrder
    image?: SortOrder
  }

  export type free_courseWhereUniqueInput = {
    freeCourse_id?: number
  }

  export type free_courseScalarWhereWithAggregatesInput = {
    AND?: Enumerable<free_courseScalarWhereWithAggregatesInput>
    OR?: Enumerable<free_courseScalarWhereWithAggregatesInput>
    NOT?: Enumerable<free_courseScalarWhereWithAggregatesInput>
    freeCourse_id?: IntWithAggregatesFilter | number
    teacher?: IntWithAggregatesFilter | number
    title?: StringWithAggregatesFilter | string
    category?: StringWithAggregatesFilter | string
    Status?: StringWithAggregatesFilter | string
    document?: IntWithAggregatesFilter | number
    image?: StringWithAggregatesFilter | string
  }

  export type feedbackWhereInput = {
    AND?: Enumerable<feedbackWhereInput>
    OR?: Enumerable<feedbackWhereInput>
    NOT?: Enumerable<feedbackWhereInput>
    feedback_id?: IntFilter | number
    student?: IntFilter | number
    stars?: IntFilter | number
    comment?: StringFilter | string
    student_id?: XOR<StudentRelationFilter, studentWhereInput>
  }

  export type feedbackOrderByInput = {
    feedback_id?: SortOrder
    student?: SortOrder
    stars?: SortOrder
    comment?: SortOrder
  }

  export type feedbackWhereUniqueInput = {
    feedback_id?: number
    student?: number
  }

  export type feedbackScalarWhereWithAggregatesInput = {
    AND?: Enumerable<feedbackScalarWhereWithAggregatesInput>
    OR?: Enumerable<feedbackScalarWhereWithAggregatesInput>
    NOT?: Enumerable<feedbackScalarWhereWithAggregatesInput>
    feedback_id?: IntWithAggregatesFilter | number
    student?: IntWithAggregatesFilter | number
    stars?: IntWithAggregatesFilter | number
    comment?: StringWithAggregatesFilter | string
  }

  export type studentCreateInput = {
    userName: string
    password: string
    education: string
    age: number
    wallet?: number
    image: string
    email: string
    token?: string
    DM?: feedbackCreateNestedManyWithoutStudent_idInput
    review?: reviewCreateNestedManyWithoutStudentInput
    schedule?: scheduleCreateNestedManyWithoutStudent_idInput
  }

  export type studentUncheckedCreateInput = {
    student_id?: number
    userName: string
    password: string
    education: string
    age: number
    wallet?: number
    image: string
    email: string
    token?: string
    DM?: feedbackUncheckedCreateNestedManyWithoutStudent_idInput
    review?: reviewUncheckedCreateNestedManyWithoutStudentInput
    schedule?: scheduleUncheckedCreateNestedManyWithoutStudent_idInput
  }

  export type studentUpdateInput = {
    userName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    education?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    wallet?: IntFieldUpdateOperationsInput | number
    image?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    DM?: feedbackUpdateManyWithoutStudent_idInput
    review?: reviewUpdateManyWithoutStudentInput
    schedule?: scheduleUpdateManyWithoutStudent_idInput
  }

  export type studentUncheckedUpdateInput = {
    student_id?: IntFieldUpdateOperationsInput | number
    userName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    education?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    wallet?: IntFieldUpdateOperationsInput | number
    image?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    DM?: feedbackUncheckedUpdateManyWithoutStudent_idInput
    review?: reviewUncheckedUpdateManyWithoutStudentInput
    schedule?: scheduleUncheckedUpdateManyWithoutStudent_idInput
  }

  export type studentCreateManyInput = {
    student_id?: number
    userName: string
    password: string
    education: string
    age: number
    wallet?: number
    image: string
    email: string
    token?: string
  }

  export type studentUpdateManyMutationInput = {
    userName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    education?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    wallet?: IntFieldUpdateOperationsInput | number
    image?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
  }

  export type studentUncheckedUpdateManyInput = {
    student_id?: IntFieldUpdateOperationsInput | number
    userName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    education?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    wallet?: IntFieldUpdateOperationsInput | number
    image?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
  }

  export type teacherCreateInput = {
    sumOfRates?: number
    email: string
    userName: string
    password: string
    education: string
    description?: string
    age: number
    wallet?: number
    image: string
    token?: string
    Overall_rating?: number
    numberOfRates?: number
    free_course?: free_courseCreateNestedManyWithoutTeacher_idInput
    post?: postCreateNestedManyWithoutAuthorInput
    review?: reviewCreateNestedManyWithoutTeacherInput
    schedule?: scheduleCreateNestedManyWithoutTeacher_idInput
    sessions?: sessionsCreateNestedOneWithoutTeacherInput
    weekDay?: weekDayCreateNestedOneWithoutTeacherInput
  }

  export type teacherUncheckedCreateInput = {
    teacher_id?: number
    sumOfRates?: number
    email: string
    userName: string
    password: string
    education: string
    description?: string
    age: number
    wallet?: number
    image: string
    token?: string
    Overall_rating?: number
    numberOfRates?: number
    free_course?: free_courseUncheckedCreateNestedManyWithoutTeacher_idInput
    post?: postUncheckedCreateNestedManyWithoutAuthorInput
    review?: reviewUncheckedCreateNestedManyWithoutTeacherInput
    schedule?: scheduleUncheckedCreateNestedManyWithoutTeacher_idInput
    sessions?: sessionsUncheckedCreateNestedOneWithoutTeacherInput
    weekDay?: weekDayUncheckedCreateNestedOneWithoutTeacherInput
  }

  export type teacherUpdateInput = {
    sumOfRates?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    education?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    wallet?: IntFieldUpdateOperationsInput | number
    image?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    Overall_rating?: IntFieldUpdateOperationsInput | number
    numberOfRates?: IntFieldUpdateOperationsInput | number
    free_course?: free_courseUpdateManyWithoutTeacher_idInput
    post?: postUpdateManyWithoutAuthorInput
    review?: reviewUpdateManyWithoutTeacherInput
    schedule?: scheduleUpdateManyWithoutTeacher_idInput
    sessions?: sessionsUpdateOneWithoutTeacherInput
    weekDay?: weekDayUpdateOneWithoutTeacherInput
  }

  export type teacherUncheckedUpdateInput = {
    teacher_id?: IntFieldUpdateOperationsInput | number
    sumOfRates?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    education?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    wallet?: IntFieldUpdateOperationsInput | number
    image?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    Overall_rating?: IntFieldUpdateOperationsInput | number
    numberOfRates?: IntFieldUpdateOperationsInput | number
    free_course?: free_courseUncheckedUpdateManyWithoutTeacher_idInput
    post?: postUncheckedUpdateManyWithoutAuthorInput
    review?: reviewUncheckedUpdateManyWithoutTeacherInput
    schedule?: scheduleUncheckedUpdateManyWithoutTeacher_idInput
    sessions?: sessionsUncheckedUpdateOneWithoutTeacherInput
    weekDay?: weekDayUncheckedUpdateOneWithoutTeacherInput
  }

  export type teacherCreateManyInput = {
    teacher_id?: number
    sumOfRates?: number
    email: string
    userName: string
    password: string
    education: string
    description?: string
    age: number
    wallet?: number
    image: string
    token?: string
    Overall_rating?: number
    numberOfRates?: number
  }

  export type teacherUpdateManyMutationInput = {
    sumOfRates?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    education?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    wallet?: IntFieldUpdateOperationsInput | number
    image?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    Overall_rating?: IntFieldUpdateOperationsInput | number
    numberOfRates?: IntFieldUpdateOperationsInput | number
  }

  export type teacherUncheckedUpdateManyInput = {
    teacher_id?: IntFieldUpdateOperationsInput | number
    sumOfRates?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    education?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    wallet?: IntFieldUpdateOperationsInput | number
    image?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    Overall_rating?: IntFieldUpdateOperationsInput | number
    numberOfRates?: IntFieldUpdateOperationsInput | number
  }

  export type weekDayCreateInput = {
    monday?: boolean
    tuesday?: boolean
    wednesday?: boolean
    thursday?: boolean
    friday?: boolean
    saturday?: boolean
    sunday?: boolean
    teacher: teacherCreateNestedOneWithoutWeekDayInput
  }

  export type weekDayUncheckedCreateInput = {
    weekDay_id?: number
    teacher_id: number
    monday?: boolean
    tuesday?: boolean
    wednesday?: boolean
    thursday?: boolean
    friday?: boolean
    saturday?: boolean
    sunday?: boolean
  }

  export type weekDayUpdateInput = {
    monday?: BoolFieldUpdateOperationsInput | boolean
    tuesday?: BoolFieldUpdateOperationsInput | boolean
    wednesday?: BoolFieldUpdateOperationsInput | boolean
    thursday?: BoolFieldUpdateOperationsInput | boolean
    friday?: BoolFieldUpdateOperationsInput | boolean
    saturday?: BoolFieldUpdateOperationsInput | boolean
    sunday?: BoolFieldUpdateOperationsInput | boolean
    teacher?: teacherUpdateOneRequiredWithoutWeekDayInput
  }

  export type weekDayUncheckedUpdateInput = {
    weekDay_id?: IntFieldUpdateOperationsInput | number
    teacher_id?: IntFieldUpdateOperationsInput | number
    monday?: BoolFieldUpdateOperationsInput | boolean
    tuesday?: BoolFieldUpdateOperationsInput | boolean
    wednesday?: BoolFieldUpdateOperationsInput | boolean
    thursday?: BoolFieldUpdateOperationsInput | boolean
    friday?: BoolFieldUpdateOperationsInput | boolean
    saturday?: BoolFieldUpdateOperationsInput | boolean
    sunday?: BoolFieldUpdateOperationsInput | boolean
  }

  export type weekDayCreateManyInput = {
    weekDay_id?: number
    teacher_id: number
    monday?: boolean
    tuesday?: boolean
    wednesday?: boolean
    thursday?: boolean
    friday?: boolean
    saturday?: boolean
    sunday?: boolean
  }

  export type weekDayUpdateManyMutationInput = {
    monday?: BoolFieldUpdateOperationsInput | boolean
    tuesday?: BoolFieldUpdateOperationsInput | boolean
    wednesday?: BoolFieldUpdateOperationsInput | boolean
    thursday?: BoolFieldUpdateOperationsInput | boolean
    friday?: BoolFieldUpdateOperationsInput | boolean
    saturday?: BoolFieldUpdateOperationsInput | boolean
    sunday?: BoolFieldUpdateOperationsInput | boolean
  }

  export type weekDayUncheckedUpdateManyInput = {
    weekDay_id?: IntFieldUpdateOperationsInput | number
    teacher_id?: IntFieldUpdateOperationsInput | number
    monday?: BoolFieldUpdateOperationsInput | boolean
    tuesday?: BoolFieldUpdateOperationsInput | boolean
    wednesday?: BoolFieldUpdateOperationsInput | boolean
    thursday?: BoolFieldUpdateOperationsInput | boolean
    friday?: BoolFieldUpdateOperationsInput | boolean
    saturday?: BoolFieldUpdateOperationsInput | boolean
    sunday?: BoolFieldUpdateOperationsInput | boolean
  }

  export type sessionsCreateInput = {
    one?: boolean
    two?: boolean
    three?: boolean
    four?: boolean
    five?: boolean
    six?: boolean
    teacher: teacherCreateNestedOneWithoutSessionsInput
  }

  export type sessionsUncheckedCreateInput = {
    sessions_id?: number
    teacher_id: number
    one?: boolean
    two?: boolean
    three?: boolean
    four?: boolean
    five?: boolean
    six?: boolean
  }

  export type sessionsUpdateInput = {
    one?: BoolFieldUpdateOperationsInput | boolean
    two?: BoolFieldUpdateOperationsInput | boolean
    three?: BoolFieldUpdateOperationsInput | boolean
    four?: BoolFieldUpdateOperationsInput | boolean
    five?: BoolFieldUpdateOperationsInput | boolean
    six?: BoolFieldUpdateOperationsInput | boolean
    teacher?: teacherUpdateOneRequiredWithoutSessionsInput
  }

  export type sessionsUncheckedUpdateInput = {
    sessions_id?: IntFieldUpdateOperationsInput | number
    teacher_id?: IntFieldUpdateOperationsInput | number
    one?: BoolFieldUpdateOperationsInput | boolean
    two?: BoolFieldUpdateOperationsInput | boolean
    three?: BoolFieldUpdateOperationsInput | boolean
    four?: BoolFieldUpdateOperationsInput | boolean
    five?: BoolFieldUpdateOperationsInput | boolean
    six?: BoolFieldUpdateOperationsInput | boolean
  }

  export type sessionsCreateManyInput = {
    sessions_id?: number
    teacher_id: number
    one?: boolean
    two?: boolean
    three?: boolean
    four?: boolean
    five?: boolean
    six?: boolean
  }

  export type sessionsUpdateManyMutationInput = {
    one?: BoolFieldUpdateOperationsInput | boolean
    two?: BoolFieldUpdateOperationsInput | boolean
    three?: BoolFieldUpdateOperationsInput | boolean
    four?: BoolFieldUpdateOperationsInput | boolean
    five?: BoolFieldUpdateOperationsInput | boolean
    six?: BoolFieldUpdateOperationsInput | boolean
  }

  export type sessionsUncheckedUpdateManyInput = {
    sessions_id?: IntFieldUpdateOperationsInput | number
    teacher_id?: IntFieldUpdateOperationsInput | number
    one?: BoolFieldUpdateOperationsInput | boolean
    two?: BoolFieldUpdateOperationsInput | boolean
    three?: BoolFieldUpdateOperationsInput | boolean
    four?: BoolFieldUpdateOperationsInput | boolean
    five?: BoolFieldUpdateOperationsInput | boolean
    six?: BoolFieldUpdateOperationsInput | boolean
  }

  export type postCreateInput = {
    Image: string
    status?: string
    body: string
    title: string
    price: number
    author: teacherCreateNestedOneWithoutPostInput
  }

  export type postUncheckedCreateInput = {
    post_id?: number
    author_id: number
    Image: string
    status?: string
    body: string
    title: string
    price: number
  }

  export type postUpdateInput = {
    Image?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    author?: teacherUpdateOneRequiredWithoutPostInput
  }

  export type postUncheckedUpdateInput = {
    post_id?: IntFieldUpdateOperationsInput | number
    author_id?: IntFieldUpdateOperationsInput | number
    Image?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
  }

  export type postCreateManyInput = {
    post_id?: number
    author_id: number
    Image: string
    status?: string
    body: string
    title: string
    price: number
  }

  export type postUpdateManyMutationInput = {
    Image?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
  }

  export type postUncheckedUpdateManyInput = {
    post_id?: IntFieldUpdateOperationsInput | number
    author_id?: IntFieldUpdateOperationsInput | number
    Image?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
  }

  export type reviewCreateInput = {
    overallRating: number
    ratesNumber: number
    comments?: string
    student: studentCreateNestedOneWithoutReviewInput
    teacher: teacherCreateNestedOneWithoutReviewInput
  }

  export type reviewUncheckedCreateInput = {
    review_id?: number
    overallRating: number
    ratesNumber: number
    student_id: number
    teacher_id: number
    comments?: string
  }

  export type reviewUpdateInput = {
    overallRating?: IntFieldUpdateOperationsInput | number
    ratesNumber?: IntFieldUpdateOperationsInput | number
    comments?: StringFieldUpdateOperationsInput | string
    student?: studentUpdateOneRequiredWithoutReviewInput
    teacher?: teacherUpdateOneRequiredWithoutReviewInput
  }

  export type reviewUncheckedUpdateInput = {
    review_id?: IntFieldUpdateOperationsInput | number
    overallRating?: IntFieldUpdateOperationsInput | number
    ratesNumber?: IntFieldUpdateOperationsInput | number
    student_id?: IntFieldUpdateOperationsInput | number
    teacher_id?: IntFieldUpdateOperationsInput | number
    comments?: StringFieldUpdateOperationsInput | string
  }

  export type reviewCreateManyInput = {
    review_id?: number
    overallRating: number
    ratesNumber: number
    student_id: number
    teacher_id: number
    comments?: string
  }

  export type reviewUpdateManyMutationInput = {
    overallRating?: IntFieldUpdateOperationsInput | number
    ratesNumber?: IntFieldUpdateOperationsInput | number
    comments?: StringFieldUpdateOperationsInput | string
  }

  export type reviewUncheckedUpdateManyInput = {
    review_id?: IntFieldUpdateOperationsInput | number
    overallRating?: IntFieldUpdateOperationsInput | number
    ratesNumber?: IntFieldUpdateOperationsInput | number
    student_id?: IntFieldUpdateOperationsInput | number
    teacher_id?: IntFieldUpdateOperationsInput | number
    comments?: StringFieldUpdateOperationsInput | string
  }

  export type scheduleCreateInput = {
    day: string
    session: string
    student_id: studentCreateNestedOneWithoutScheduleInput
    teacher_id: teacherCreateNestedOneWithoutScheduleInput
  }

  export type scheduleUncheckedCreateInput = {
    scheduel_id?: number
    student: number
    teacher: number
    day: string
    session: string
  }

  export type scheduleUpdateInput = {
    day?: StringFieldUpdateOperationsInput | string
    session?: StringFieldUpdateOperationsInput | string
    student_id?: studentUpdateOneRequiredWithoutScheduleInput
    teacher_id?: teacherUpdateOneRequiredWithoutScheduleInput
  }

  export type scheduleUncheckedUpdateInput = {
    scheduel_id?: IntFieldUpdateOperationsInput | number
    student?: IntFieldUpdateOperationsInput | number
    teacher?: IntFieldUpdateOperationsInput | number
    day?: StringFieldUpdateOperationsInput | string
    session?: StringFieldUpdateOperationsInput | string
  }

  export type scheduleCreateManyInput = {
    scheduel_id?: number
    student: number
    teacher: number
    day: string
    session: string
  }

  export type scheduleUpdateManyMutationInput = {
    day?: StringFieldUpdateOperationsInput | string
    session?: StringFieldUpdateOperationsInput | string
  }

  export type scheduleUncheckedUpdateManyInput = {
    scheduel_id?: IntFieldUpdateOperationsInput | number
    student?: IntFieldUpdateOperationsInput | number
    teacher?: IntFieldUpdateOperationsInput | number
    day?: StringFieldUpdateOperationsInput | string
    session?: StringFieldUpdateOperationsInput | string
  }

  export type attachementCreateInput = {
    Type: string
    attachement: string
    body: string
    free_course?: free_courseCreateNestedManyWithoutAttachementInput
  }

  export type attachementUncheckedCreateInput = {
    attachement_id?: number
    Type: string
    attachement: string
    body: string
    free_course?: free_courseUncheckedCreateNestedManyWithoutAttachementInput
  }

  export type attachementUpdateInput = {
    Type?: StringFieldUpdateOperationsInput | string
    attachement?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    free_course?: free_courseUpdateManyWithoutAttachementInput
  }

  export type attachementUncheckedUpdateInput = {
    attachement_id?: IntFieldUpdateOperationsInput | number
    Type?: StringFieldUpdateOperationsInput | string
    attachement?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    free_course?: free_courseUncheckedUpdateManyWithoutAttachementInput
  }

  export type attachementCreateManyInput = {
    attachement_id?: number
    Type: string
    attachement: string
    body: string
  }

  export type attachementUpdateManyMutationInput = {
    Type?: StringFieldUpdateOperationsInput | string
    attachement?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
  }

  export type attachementUncheckedUpdateManyInput = {
    attachement_id?: IntFieldUpdateOperationsInput | number
    Type?: StringFieldUpdateOperationsInput | string
    attachement?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
  }

  export type free_courseCreateInput = {
    title: string
    category: string
    Status?: string
    image: string
    attachement: attachementCreateNestedOneWithoutFree_courseInput
    teacher_id: teacherCreateNestedOneWithoutFree_courseInput
  }

  export type free_courseUncheckedCreateInput = {
    freeCourse_id?: number
    teacher: number
    title: string
    category: string
    Status?: string
    document: number
    image: string
  }

  export type free_courseUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    Status?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    attachement?: attachementUpdateOneRequiredWithoutFree_courseInput
    teacher_id?: teacherUpdateOneRequiredWithoutFree_courseInput
  }

  export type free_courseUncheckedUpdateInput = {
    freeCourse_id?: IntFieldUpdateOperationsInput | number
    teacher?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    Status?: StringFieldUpdateOperationsInput | string
    document?: IntFieldUpdateOperationsInput | number
    image?: StringFieldUpdateOperationsInput | string
  }

  export type free_courseCreateManyInput = {
    freeCourse_id?: number
    teacher: number
    title: string
    category: string
    Status?: string
    document: number
    image: string
  }

  export type free_courseUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    Status?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
  }

  export type free_courseUncheckedUpdateManyInput = {
    freeCourse_id?: IntFieldUpdateOperationsInput | number
    teacher?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    Status?: StringFieldUpdateOperationsInput | string
    document?: IntFieldUpdateOperationsInput | number
    image?: StringFieldUpdateOperationsInput | string
  }

  export type feedbackCreateInput = {
    stars: number
    comment: string
    student_id: studentCreateNestedOneWithoutDMInput
  }

  export type feedbackUncheckedCreateInput = {
    feedback_id?: number
    student: number
    stars: number
    comment: string
  }

  export type feedbackUpdateInput = {
    stars?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    student_id?: studentUpdateOneRequiredWithoutDMInput
  }

  export type feedbackUncheckedUpdateInput = {
    feedback_id?: IntFieldUpdateOperationsInput | number
    student?: IntFieldUpdateOperationsInput | number
    stars?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
  }

  export type feedbackCreateManyInput = {
    feedback_id?: number
    student: number
    stars: number
    comment: string
  }

  export type feedbackUpdateManyMutationInput = {
    stars?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
  }

  export type feedbackUncheckedUpdateManyInput = {
    feedback_id?: IntFieldUpdateOperationsInput | number
    student?: IntFieldUpdateOperationsInput | number
    stars?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
  }

  export type IntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringFilter | string
  }

  export type FeedbackListRelationFilter = {
    every?: feedbackWhereInput
    some?: feedbackWhereInput
    none?: feedbackWhereInput
  }

  export type ReviewListRelationFilter = {
    every?: reviewWhereInput
    some?: reviewWhereInput
    none?: reviewWhereInput
  }

  export type ScheduleListRelationFilter = {
    every?: scheduleWhereInput
    some?: scheduleWhereInput
    none?: scheduleWhereInput
  }

  export type IntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntFilter
    _avg?: NestedFloatFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    sum?: NestedIntFilter
    _min?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedIntFilter
    _max?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedIntFilter
  }

  export type StringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntFilter
    _min?: NestedStringFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedStringFilter
    _max?: NestedStringFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedStringFilter
  }

  export type Free_courseListRelationFilter = {
    every?: free_courseWhereInput
    some?: free_courseWhereInput
    none?: free_courseWhereInput
  }

  export type PostListRelationFilter = {
    every?: postWhereInput
    some?: postWhereInput
    none?: postWhereInput
  }

  export type SessionsRelationFilter = {
    is?: sessionsWhereInput | null
    isNot?: sessionsWhereInput | null
  }

  export type WeekDayRelationFilter = {
    is?: weekDayWhereInput | null
    isNot?: weekDayWhereInput | null
  }

  export type BoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type TeacherRelationFilter = {
    is?: teacherWhereInput
    isNot?: teacherWhereInput
  }

  export type BoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntFilter
    _min?: NestedBoolFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedBoolFilter
    _max?: NestedBoolFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedBoolFilter
  }

  export type StudentRelationFilter = {
    is?: studentWhereInput
    isNot?: studentWhereInput
  }

  export type AttachementRelationFilter = {
    is?: attachementWhereInput
    isNot?: attachementWhereInput
  }

  export type feedbackCreateNestedManyWithoutStudent_idInput = {
    create?: XOR<Enumerable<feedbackCreateWithoutStudent_idInput>, Enumerable<feedbackUncheckedCreateWithoutStudent_idInput>>
    connectOrCreate?: Enumerable<feedbackCreateOrConnectWithoutStudent_idInput>
    createMany?: feedbackCreateManyStudent_idInputEnvelope
    connect?: Enumerable<feedbackWhereUniqueInput>
  }

  export type reviewCreateNestedManyWithoutStudentInput = {
    create?: XOR<Enumerable<reviewCreateWithoutStudentInput>, Enumerable<reviewUncheckedCreateWithoutStudentInput>>
    connectOrCreate?: Enumerable<reviewCreateOrConnectWithoutStudentInput>
    createMany?: reviewCreateManyStudentInputEnvelope
    connect?: Enumerable<reviewWhereUniqueInput>
  }

  export type scheduleCreateNestedManyWithoutStudent_idInput = {
    create?: XOR<Enumerable<scheduleCreateWithoutStudent_idInput>, Enumerable<scheduleUncheckedCreateWithoutStudent_idInput>>
    connectOrCreate?: Enumerable<scheduleCreateOrConnectWithoutStudent_idInput>
    createMany?: scheduleCreateManyStudent_idInputEnvelope
    connect?: Enumerable<scheduleWhereUniqueInput>
  }

  export type feedbackUncheckedCreateNestedManyWithoutStudent_idInput = {
    create?: XOR<Enumerable<feedbackCreateWithoutStudent_idInput>, Enumerable<feedbackUncheckedCreateWithoutStudent_idInput>>
    connectOrCreate?: Enumerable<feedbackCreateOrConnectWithoutStudent_idInput>
    createMany?: feedbackCreateManyStudent_idInputEnvelope
    connect?: Enumerable<feedbackWhereUniqueInput>
  }

  export type reviewUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<Enumerable<reviewCreateWithoutStudentInput>, Enumerable<reviewUncheckedCreateWithoutStudentInput>>
    connectOrCreate?: Enumerable<reviewCreateOrConnectWithoutStudentInput>
    createMany?: reviewCreateManyStudentInputEnvelope
    connect?: Enumerable<reviewWhereUniqueInput>
  }

  export type scheduleUncheckedCreateNestedManyWithoutStudent_idInput = {
    create?: XOR<Enumerable<scheduleCreateWithoutStudent_idInput>, Enumerable<scheduleUncheckedCreateWithoutStudent_idInput>>
    connectOrCreate?: Enumerable<scheduleCreateOrConnectWithoutStudent_idInput>
    createMany?: scheduleCreateManyStudent_idInputEnvelope
    connect?: Enumerable<scheduleWhereUniqueInput>
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type feedbackUpdateManyWithoutStudent_idInput = {
    create?: XOR<Enumerable<feedbackCreateWithoutStudent_idInput>, Enumerable<feedbackUncheckedCreateWithoutStudent_idInput>>
    connectOrCreate?: Enumerable<feedbackCreateOrConnectWithoutStudent_idInput>
    upsert?: Enumerable<feedbackUpsertWithWhereUniqueWithoutStudent_idInput>
    createMany?: feedbackCreateManyStudent_idInputEnvelope
    connect?: Enumerable<feedbackWhereUniqueInput>
    set?: Enumerable<feedbackWhereUniqueInput>
    disconnect?: Enumerable<feedbackWhereUniqueInput>
    delete?: Enumerable<feedbackWhereUniqueInput>
    update?: Enumerable<feedbackUpdateWithWhereUniqueWithoutStudent_idInput>
    updateMany?: Enumerable<feedbackUpdateManyWithWhereWithoutStudent_idInput>
    deleteMany?: Enumerable<feedbackScalarWhereInput>
  }

  export type reviewUpdateManyWithoutStudentInput = {
    create?: XOR<Enumerable<reviewCreateWithoutStudentInput>, Enumerable<reviewUncheckedCreateWithoutStudentInput>>
    connectOrCreate?: Enumerable<reviewCreateOrConnectWithoutStudentInput>
    upsert?: Enumerable<reviewUpsertWithWhereUniqueWithoutStudentInput>
    createMany?: reviewCreateManyStudentInputEnvelope
    connect?: Enumerable<reviewWhereUniqueInput>
    set?: Enumerable<reviewWhereUniqueInput>
    disconnect?: Enumerable<reviewWhereUniqueInput>
    delete?: Enumerable<reviewWhereUniqueInput>
    update?: Enumerable<reviewUpdateWithWhereUniqueWithoutStudentInput>
    updateMany?: Enumerable<reviewUpdateManyWithWhereWithoutStudentInput>
    deleteMany?: Enumerable<reviewScalarWhereInput>
  }

  export type scheduleUpdateManyWithoutStudent_idInput = {
    create?: XOR<Enumerable<scheduleCreateWithoutStudent_idInput>, Enumerable<scheduleUncheckedCreateWithoutStudent_idInput>>
    connectOrCreate?: Enumerable<scheduleCreateOrConnectWithoutStudent_idInput>
    upsert?: Enumerable<scheduleUpsertWithWhereUniqueWithoutStudent_idInput>
    createMany?: scheduleCreateManyStudent_idInputEnvelope
    connect?: Enumerable<scheduleWhereUniqueInput>
    set?: Enumerable<scheduleWhereUniqueInput>
    disconnect?: Enumerable<scheduleWhereUniqueInput>
    delete?: Enumerable<scheduleWhereUniqueInput>
    update?: Enumerable<scheduleUpdateWithWhereUniqueWithoutStudent_idInput>
    updateMany?: Enumerable<scheduleUpdateManyWithWhereWithoutStudent_idInput>
    deleteMany?: Enumerable<scheduleScalarWhereInput>
  }

  export type feedbackUncheckedUpdateManyWithoutStudent_idInput = {
    create?: XOR<Enumerable<feedbackCreateWithoutStudent_idInput>, Enumerable<feedbackUncheckedCreateWithoutStudent_idInput>>
    connectOrCreate?: Enumerable<feedbackCreateOrConnectWithoutStudent_idInput>
    upsert?: Enumerable<feedbackUpsertWithWhereUniqueWithoutStudent_idInput>
    createMany?: feedbackCreateManyStudent_idInputEnvelope
    connect?: Enumerable<feedbackWhereUniqueInput>
    set?: Enumerable<feedbackWhereUniqueInput>
    disconnect?: Enumerable<feedbackWhereUniqueInput>
    delete?: Enumerable<feedbackWhereUniqueInput>
    update?: Enumerable<feedbackUpdateWithWhereUniqueWithoutStudent_idInput>
    updateMany?: Enumerable<feedbackUpdateManyWithWhereWithoutStudent_idInput>
    deleteMany?: Enumerable<feedbackScalarWhereInput>
  }

  export type reviewUncheckedUpdateManyWithoutStudentInput = {
    create?: XOR<Enumerable<reviewCreateWithoutStudentInput>, Enumerable<reviewUncheckedCreateWithoutStudentInput>>
    connectOrCreate?: Enumerable<reviewCreateOrConnectWithoutStudentInput>
    upsert?: Enumerable<reviewUpsertWithWhereUniqueWithoutStudentInput>
    createMany?: reviewCreateManyStudentInputEnvelope
    connect?: Enumerable<reviewWhereUniqueInput>
    set?: Enumerable<reviewWhereUniqueInput>
    disconnect?: Enumerable<reviewWhereUniqueInput>
    delete?: Enumerable<reviewWhereUniqueInput>
    update?: Enumerable<reviewUpdateWithWhereUniqueWithoutStudentInput>
    updateMany?: Enumerable<reviewUpdateManyWithWhereWithoutStudentInput>
    deleteMany?: Enumerable<reviewScalarWhereInput>
  }

  export type scheduleUncheckedUpdateManyWithoutStudent_idInput = {
    create?: XOR<Enumerable<scheduleCreateWithoutStudent_idInput>, Enumerable<scheduleUncheckedCreateWithoutStudent_idInput>>
    connectOrCreate?: Enumerable<scheduleCreateOrConnectWithoutStudent_idInput>
    upsert?: Enumerable<scheduleUpsertWithWhereUniqueWithoutStudent_idInput>
    createMany?: scheduleCreateManyStudent_idInputEnvelope
    connect?: Enumerable<scheduleWhereUniqueInput>
    set?: Enumerable<scheduleWhereUniqueInput>
    disconnect?: Enumerable<scheduleWhereUniqueInput>
    delete?: Enumerable<scheduleWhereUniqueInput>
    update?: Enumerable<scheduleUpdateWithWhereUniqueWithoutStudent_idInput>
    updateMany?: Enumerable<scheduleUpdateManyWithWhereWithoutStudent_idInput>
    deleteMany?: Enumerable<scheduleScalarWhereInput>
  }

  export type free_courseCreateNestedManyWithoutTeacher_idInput = {
    create?: XOR<Enumerable<free_courseCreateWithoutTeacher_idInput>, Enumerable<free_courseUncheckedCreateWithoutTeacher_idInput>>
    connectOrCreate?: Enumerable<free_courseCreateOrConnectWithoutTeacher_idInput>
    createMany?: free_courseCreateManyTeacher_idInputEnvelope
    connect?: Enumerable<free_courseWhereUniqueInput>
  }

  export type postCreateNestedManyWithoutAuthorInput = {
    create?: XOR<Enumerable<postCreateWithoutAuthorInput>, Enumerable<postUncheckedCreateWithoutAuthorInput>>
    connectOrCreate?: Enumerable<postCreateOrConnectWithoutAuthorInput>
    createMany?: postCreateManyAuthorInputEnvelope
    connect?: Enumerable<postWhereUniqueInput>
  }

  export type reviewCreateNestedManyWithoutTeacherInput = {
    create?: XOR<Enumerable<reviewCreateWithoutTeacherInput>, Enumerable<reviewUncheckedCreateWithoutTeacherInput>>
    connectOrCreate?: Enumerable<reviewCreateOrConnectWithoutTeacherInput>
    createMany?: reviewCreateManyTeacherInputEnvelope
    connect?: Enumerable<reviewWhereUniqueInput>
  }

  export type scheduleCreateNestedManyWithoutTeacher_idInput = {
    create?: XOR<Enumerable<scheduleCreateWithoutTeacher_idInput>, Enumerable<scheduleUncheckedCreateWithoutTeacher_idInput>>
    connectOrCreate?: Enumerable<scheduleCreateOrConnectWithoutTeacher_idInput>
    createMany?: scheduleCreateManyTeacher_idInputEnvelope
    connect?: Enumerable<scheduleWhereUniqueInput>
  }

  export type sessionsCreateNestedOneWithoutTeacherInput = {
    create?: XOR<sessionsCreateWithoutTeacherInput, sessionsUncheckedCreateWithoutTeacherInput>
    connectOrCreate?: sessionsCreateOrConnectWithoutTeacherInput
    connect?: sessionsWhereUniqueInput
  }

  export type weekDayCreateNestedOneWithoutTeacherInput = {
    create?: XOR<weekDayCreateWithoutTeacherInput, weekDayUncheckedCreateWithoutTeacherInput>
    connectOrCreate?: weekDayCreateOrConnectWithoutTeacherInput
    connect?: weekDayWhereUniqueInput
  }

  export type free_courseUncheckedCreateNestedManyWithoutTeacher_idInput = {
    create?: XOR<Enumerable<free_courseCreateWithoutTeacher_idInput>, Enumerable<free_courseUncheckedCreateWithoutTeacher_idInput>>
    connectOrCreate?: Enumerable<free_courseCreateOrConnectWithoutTeacher_idInput>
    createMany?: free_courseCreateManyTeacher_idInputEnvelope
    connect?: Enumerable<free_courseWhereUniqueInput>
  }

  export type postUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<Enumerable<postCreateWithoutAuthorInput>, Enumerable<postUncheckedCreateWithoutAuthorInput>>
    connectOrCreate?: Enumerable<postCreateOrConnectWithoutAuthorInput>
    createMany?: postCreateManyAuthorInputEnvelope
    connect?: Enumerable<postWhereUniqueInput>
  }

  export type reviewUncheckedCreateNestedManyWithoutTeacherInput = {
    create?: XOR<Enumerable<reviewCreateWithoutTeacherInput>, Enumerable<reviewUncheckedCreateWithoutTeacherInput>>
    connectOrCreate?: Enumerable<reviewCreateOrConnectWithoutTeacherInput>
    createMany?: reviewCreateManyTeacherInputEnvelope
    connect?: Enumerable<reviewWhereUniqueInput>
  }

  export type scheduleUncheckedCreateNestedManyWithoutTeacher_idInput = {
    create?: XOR<Enumerable<scheduleCreateWithoutTeacher_idInput>, Enumerable<scheduleUncheckedCreateWithoutTeacher_idInput>>
    connectOrCreate?: Enumerable<scheduleCreateOrConnectWithoutTeacher_idInput>
    createMany?: scheduleCreateManyTeacher_idInputEnvelope
    connect?: Enumerable<scheduleWhereUniqueInput>
  }

  export type sessionsUncheckedCreateNestedOneWithoutTeacherInput = {
    create?: XOR<sessionsCreateWithoutTeacherInput, sessionsUncheckedCreateWithoutTeacherInput>
    connectOrCreate?: sessionsCreateOrConnectWithoutTeacherInput
    connect?: sessionsWhereUniqueInput
  }

  export type weekDayUncheckedCreateNestedOneWithoutTeacherInput = {
    create?: XOR<weekDayCreateWithoutTeacherInput, weekDayUncheckedCreateWithoutTeacherInput>
    connectOrCreate?: weekDayCreateOrConnectWithoutTeacherInput
    connect?: weekDayWhereUniqueInput
  }

  export type free_courseUpdateManyWithoutTeacher_idInput = {
    create?: XOR<Enumerable<free_courseCreateWithoutTeacher_idInput>, Enumerable<free_courseUncheckedCreateWithoutTeacher_idInput>>
    connectOrCreate?: Enumerable<free_courseCreateOrConnectWithoutTeacher_idInput>
    upsert?: Enumerable<free_courseUpsertWithWhereUniqueWithoutTeacher_idInput>
    createMany?: free_courseCreateManyTeacher_idInputEnvelope
    connect?: Enumerable<free_courseWhereUniqueInput>
    set?: Enumerable<free_courseWhereUniqueInput>
    disconnect?: Enumerable<free_courseWhereUniqueInput>
    delete?: Enumerable<free_courseWhereUniqueInput>
    update?: Enumerable<free_courseUpdateWithWhereUniqueWithoutTeacher_idInput>
    updateMany?: Enumerable<free_courseUpdateManyWithWhereWithoutTeacher_idInput>
    deleteMany?: Enumerable<free_courseScalarWhereInput>
  }

  export type postUpdateManyWithoutAuthorInput = {
    create?: XOR<Enumerable<postCreateWithoutAuthorInput>, Enumerable<postUncheckedCreateWithoutAuthorInput>>
    connectOrCreate?: Enumerable<postCreateOrConnectWithoutAuthorInput>
    upsert?: Enumerable<postUpsertWithWhereUniqueWithoutAuthorInput>
    createMany?: postCreateManyAuthorInputEnvelope
    connect?: Enumerable<postWhereUniqueInput>
    set?: Enumerable<postWhereUniqueInput>
    disconnect?: Enumerable<postWhereUniqueInput>
    delete?: Enumerable<postWhereUniqueInput>
    update?: Enumerable<postUpdateWithWhereUniqueWithoutAuthorInput>
    updateMany?: Enumerable<postUpdateManyWithWhereWithoutAuthorInput>
    deleteMany?: Enumerable<postScalarWhereInput>
  }

  export type reviewUpdateManyWithoutTeacherInput = {
    create?: XOR<Enumerable<reviewCreateWithoutTeacherInput>, Enumerable<reviewUncheckedCreateWithoutTeacherInput>>
    connectOrCreate?: Enumerable<reviewCreateOrConnectWithoutTeacherInput>
    upsert?: Enumerable<reviewUpsertWithWhereUniqueWithoutTeacherInput>
    createMany?: reviewCreateManyTeacherInputEnvelope
    connect?: Enumerable<reviewWhereUniqueInput>
    set?: Enumerable<reviewWhereUniqueInput>
    disconnect?: Enumerable<reviewWhereUniqueInput>
    delete?: Enumerable<reviewWhereUniqueInput>
    update?: Enumerable<reviewUpdateWithWhereUniqueWithoutTeacherInput>
    updateMany?: Enumerable<reviewUpdateManyWithWhereWithoutTeacherInput>
    deleteMany?: Enumerable<reviewScalarWhereInput>
  }

  export type scheduleUpdateManyWithoutTeacher_idInput = {
    create?: XOR<Enumerable<scheduleCreateWithoutTeacher_idInput>, Enumerable<scheduleUncheckedCreateWithoutTeacher_idInput>>
    connectOrCreate?: Enumerable<scheduleCreateOrConnectWithoutTeacher_idInput>
    upsert?: Enumerable<scheduleUpsertWithWhereUniqueWithoutTeacher_idInput>
    createMany?: scheduleCreateManyTeacher_idInputEnvelope
    connect?: Enumerable<scheduleWhereUniqueInput>
    set?: Enumerable<scheduleWhereUniqueInput>
    disconnect?: Enumerable<scheduleWhereUniqueInput>
    delete?: Enumerable<scheduleWhereUniqueInput>
    update?: Enumerable<scheduleUpdateWithWhereUniqueWithoutTeacher_idInput>
    updateMany?: Enumerable<scheduleUpdateManyWithWhereWithoutTeacher_idInput>
    deleteMany?: Enumerable<scheduleScalarWhereInput>
  }

  export type sessionsUpdateOneWithoutTeacherInput = {
    create?: XOR<sessionsCreateWithoutTeacherInput, sessionsUncheckedCreateWithoutTeacherInput>
    connectOrCreate?: sessionsCreateOrConnectWithoutTeacherInput
    upsert?: sessionsUpsertWithoutTeacherInput
    connect?: sessionsWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<sessionsUpdateWithoutTeacherInput, sessionsUncheckedUpdateWithoutTeacherInput>
  }

  export type weekDayUpdateOneWithoutTeacherInput = {
    create?: XOR<weekDayCreateWithoutTeacherInput, weekDayUncheckedCreateWithoutTeacherInput>
    connectOrCreate?: weekDayCreateOrConnectWithoutTeacherInput
    upsert?: weekDayUpsertWithoutTeacherInput
    connect?: weekDayWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<weekDayUpdateWithoutTeacherInput, weekDayUncheckedUpdateWithoutTeacherInput>
  }

  export type free_courseUncheckedUpdateManyWithoutTeacher_idInput = {
    create?: XOR<Enumerable<free_courseCreateWithoutTeacher_idInput>, Enumerable<free_courseUncheckedCreateWithoutTeacher_idInput>>
    connectOrCreate?: Enumerable<free_courseCreateOrConnectWithoutTeacher_idInput>
    upsert?: Enumerable<free_courseUpsertWithWhereUniqueWithoutTeacher_idInput>
    createMany?: free_courseCreateManyTeacher_idInputEnvelope
    connect?: Enumerable<free_courseWhereUniqueInput>
    set?: Enumerable<free_courseWhereUniqueInput>
    disconnect?: Enumerable<free_courseWhereUniqueInput>
    delete?: Enumerable<free_courseWhereUniqueInput>
    update?: Enumerable<free_courseUpdateWithWhereUniqueWithoutTeacher_idInput>
    updateMany?: Enumerable<free_courseUpdateManyWithWhereWithoutTeacher_idInput>
    deleteMany?: Enumerable<free_courseScalarWhereInput>
  }

  export type postUncheckedUpdateManyWithoutAuthorInput = {
    create?: XOR<Enumerable<postCreateWithoutAuthorInput>, Enumerable<postUncheckedCreateWithoutAuthorInput>>
    connectOrCreate?: Enumerable<postCreateOrConnectWithoutAuthorInput>
    upsert?: Enumerable<postUpsertWithWhereUniqueWithoutAuthorInput>
    createMany?: postCreateManyAuthorInputEnvelope
    connect?: Enumerable<postWhereUniqueInput>
    set?: Enumerable<postWhereUniqueInput>
    disconnect?: Enumerable<postWhereUniqueInput>
    delete?: Enumerable<postWhereUniqueInput>
    update?: Enumerable<postUpdateWithWhereUniqueWithoutAuthorInput>
    updateMany?: Enumerable<postUpdateManyWithWhereWithoutAuthorInput>
    deleteMany?: Enumerable<postScalarWhereInput>
  }

  export type reviewUncheckedUpdateManyWithoutTeacherInput = {
    create?: XOR<Enumerable<reviewCreateWithoutTeacherInput>, Enumerable<reviewUncheckedCreateWithoutTeacherInput>>
    connectOrCreate?: Enumerable<reviewCreateOrConnectWithoutTeacherInput>
    upsert?: Enumerable<reviewUpsertWithWhereUniqueWithoutTeacherInput>
    createMany?: reviewCreateManyTeacherInputEnvelope
    connect?: Enumerable<reviewWhereUniqueInput>
    set?: Enumerable<reviewWhereUniqueInput>
    disconnect?: Enumerable<reviewWhereUniqueInput>
    delete?: Enumerable<reviewWhereUniqueInput>
    update?: Enumerable<reviewUpdateWithWhereUniqueWithoutTeacherInput>
    updateMany?: Enumerable<reviewUpdateManyWithWhereWithoutTeacherInput>
    deleteMany?: Enumerable<reviewScalarWhereInput>
  }

  export type scheduleUncheckedUpdateManyWithoutTeacher_idInput = {
    create?: XOR<Enumerable<scheduleCreateWithoutTeacher_idInput>, Enumerable<scheduleUncheckedCreateWithoutTeacher_idInput>>
    connectOrCreate?: Enumerable<scheduleCreateOrConnectWithoutTeacher_idInput>
    upsert?: Enumerable<scheduleUpsertWithWhereUniqueWithoutTeacher_idInput>
    createMany?: scheduleCreateManyTeacher_idInputEnvelope
    connect?: Enumerable<scheduleWhereUniqueInput>
    set?: Enumerable<scheduleWhereUniqueInput>
    disconnect?: Enumerable<scheduleWhereUniqueInput>
    delete?: Enumerable<scheduleWhereUniqueInput>
    update?: Enumerable<scheduleUpdateWithWhereUniqueWithoutTeacher_idInput>
    updateMany?: Enumerable<scheduleUpdateManyWithWhereWithoutTeacher_idInput>
    deleteMany?: Enumerable<scheduleScalarWhereInput>
  }

  export type sessionsUncheckedUpdateOneWithoutTeacherInput = {
    create?: XOR<sessionsCreateWithoutTeacherInput, sessionsUncheckedCreateWithoutTeacherInput>
    connectOrCreate?: sessionsCreateOrConnectWithoutTeacherInput
    upsert?: sessionsUpsertWithoutTeacherInput
    connect?: sessionsWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<sessionsUpdateWithoutTeacherInput, sessionsUncheckedUpdateWithoutTeacherInput>
  }

  export type weekDayUncheckedUpdateOneWithoutTeacherInput = {
    create?: XOR<weekDayCreateWithoutTeacherInput, weekDayUncheckedCreateWithoutTeacherInput>
    connectOrCreate?: weekDayCreateOrConnectWithoutTeacherInput
    upsert?: weekDayUpsertWithoutTeacherInput
    connect?: weekDayWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<weekDayUpdateWithoutTeacherInput, weekDayUncheckedUpdateWithoutTeacherInput>
  }

  export type teacherCreateNestedOneWithoutWeekDayInput = {
    create?: XOR<teacherCreateWithoutWeekDayInput, teacherUncheckedCreateWithoutWeekDayInput>
    connectOrCreate?: teacherCreateOrConnectWithoutWeekDayInput
    connect?: teacherWhereUniqueInput
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type teacherUpdateOneRequiredWithoutWeekDayInput = {
    create?: XOR<teacherCreateWithoutWeekDayInput, teacherUncheckedCreateWithoutWeekDayInput>
    connectOrCreate?: teacherCreateOrConnectWithoutWeekDayInput
    upsert?: teacherUpsertWithoutWeekDayInput
    connect?: teacherWhereUniqueInput
    update?: XOR<teacherUpdateWithoutWeekDayInput, teacherUncheckedUpdateWithoutWeekDayInput>
  }

  export type teacherCreateNestedOneWithoutSessionsInput = {
    create?: XOR<teacherCreateWithoutSessionsInput, teacherUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: teacherCreateOrConnectWithoutSessionsInput
    connect?: teacherWhereUniqueInput
  }

  export type teacherUpdateOneRequiredWithoutSessionsInput = {
    create?: XOR<teacherCreateWithoutSessionsInput, teacherUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: teacherCreateOrConnectWithoutSessionsInput
    upsert?: teacherUpsertWithoutSessionsInput
    connect?: teacherWhereUniqueInput
    update?: XOR<teacherUpdateWithoutSessionsInput, teacherUncheckedUpdateWithoutSessionsInput>
  }

  export type teacherCreateNestedOneWithoutPostInput = {
    create?: XOR<teacherCreateWithoutPostInput, teacherUncheckedCreateWithoutPostInput>
    connectOrCreate?: teacherCreateOrConnectWithoutPostInput
    connect?: teacherWhereUniqueInput
  }

  export type teacherUpdateOneRequiredWithoutPostInput = {
    create?: XOR<teacherCreateWithoutPostInput, teacherUncheckedCreateWithoutPostInput>
    connectOrCreate?: teacherCreateOrConnectWithoutPostInput
    upsert?: teacherUpsertWithoutPostInput
    connect?: teacherWhereUniqueInput
    update?: XOR<teacherUpdateWithoutPostInput, teacherUncheckedUpdateWithoutPostInput>
  }

  export type studentCreateNestedOneWithoutReviewInput = {
    create?: XOR<studentCreateWithoutReviewInput, studentUncheckedCreateWithoutReviewInput>
    connectOrCreate?: studentCreateOrConnectWithoutReviewInput
    connect?: studentWhereUniqueInput
  }

  export type teacherCreateNestedOneWithoutReviewInput = {
    create?: XOR<teacherCreateWithoutReviewInput, teacherUncheckedCreateWithoutReviewInput>
    connectOrCreate?: teacherCreateOrConnectWithoutReviewInput
    connect?: teacherWhereUniqueInput
  }

  export type studentUpdateOneRequiredWithoutReviewInput = {
    create?: XOR<studentCreateWithoutReviewInput, studentUncheckedCreateWithoutReviewInput>
    connectOrCreate?: studentCreateOrConnectWithoutReviewInput
    upsert?: studentUpsertWithoutReviewInput
    connect?: studentWhereUniqueInput
    update?: XOR<studentUpdateWithoutReviewInput, studentUncheckedUpdateWithoutReviewInput>
  }

  export type teacherUpdateOneRequiredWithoutReviewInput = {
    create?: XOR<teacherCreateWithoutReviewInput, teacherUncheckedCreateWithoutReviewInput>
    connectOrCreate?: teacherCreateOrConnectWithoutReviewInput
    upsert?: teacherUpsertWithoutReviewInput
    connect?: teacherWhereUniqueInput
    update?: XOR<teacherUpdateWithoutReviewInput, teacherUncheckedUpdateWithoutReviewInput>
  }

  export type studentCreateNestedOneWithoutScheduleInput = {
    create?: XOR<studentCreateWithoutScheduleInput, studentUncheckedCreateWithoutScheduleInput>
    connectOrCreate?: studentCreateOrConnectWithoutScheduleInput
    connect?: studentWhereUniqueInput
  }

  export type teacherCreateNestedOneWithoutScheduleInput = {
    create?: XOR<teacherCreateWithoutScheduleInput, teacherUncheckedCreateWithoutScheduleInput>
    connectOrCreate?: teacherCreateOrConnectWithoutScheduleInput
    connect?: teacherWhereUniqueInput
  }

  export type studentUpdateOneRequiredWithoutScheduleInput = {
    create?: XOR<studentCreateWithoutScheduleInput, studentUncheckedCreateWithoutScheduleInput>
    connectOrCreate?: studentCreateOrConnectWithoutScheduleInput
    upsert?: studentUpsertWithoutScheduleInput
    connect?: studentWhereUniqueInput
    update?: XOR<studentUpdateWithoutScheduleInput, studentUncheckedUpdateWithoutScheduleInput>
  }

  export type teacherUpdateOneRequiredWithoutScheduleInput = {
    create?: XOR<teacherCreateWithoutScheduleInput, teacherUncheckedCreateWithoutScheduleInput>
    connectOrCreate?: teacherCreateOrConnectWithoutScheduleInput
    upsert?: teacherUpsertWithoutScheduleInput
    connect?: teacherWhereUniqueInput
    update?: XOR<teacherUpdateWithoutScheduleInput, teacherUncheckedUpdateWithoutScheduleInput>
  }

  export type free_courseCreateNestedManyWithoutAttachementInput = {
    create?: XOR<Enumerable<free_courseCreateWithoutAttachementInput>, Enumerable<free_courseUncheckedCreateWithoutAttachementInput>>
    connectOrCreate?: Enumerable<free_courseCreateOrConnectWithoutAttachementInput>
    createMany?: free_courseCreateManyAttachementInputEnvelope
    connect?: Enumerable<free_courseWhereUniqueInput>
  }

  export type free_courseUncheckedCreateNestedManyWithoutAttachementInput = {
    create?: XOR<Enumerable<free_courseCreateWithoutAttachementInput>, Enumerable<free_courseUncheckedCreateWithoutAttachementInput>>
    connectOrCreate?: Enumerable<free_courseCreateOrConnectWithoutAttachementInput>
    createMany?: free_courseCreateManyAttachementInputEnvelope
    connect?: Enumerable<free_courseWhereUniqueInput>
  }

  export type free_courseUpdateManyWithoutAttachementInput = {
    create?: XOR<Enumerable<free_courseCreateWithoutAttachementInput>, Enumerable<free_courseUncheckedCreateWithoutAttachementInput>>
    connectOrCreate?: Enumerable<free_courseCreateOrConnectWithoutAttachementInput>
    upsert?: Enumerable<free_courseUpsertWithWhereUniqueWithoutAttachementInput>
    createMany?: free_courseCreateManyAttachementInputEnvelope
    connect?: Enumerable<free_courseWhereUniqueInput>
    set?: Enumerable<free_courseWhereUniqueInput>
    disconnect?: Enumerable<free_courseWhereUniqueInput>
    delete?: Enumerable<free_courseWhereUniqueInput>
    update?: Enumerable<free_courseUpdateWithWhereUniqueWithoutAttachementInput>
    updateMany?: Enumerable<free_courseUpdateManyWithWhereWithoutAttachementInput>
    deleteMany?: Enumerable<free_courseScalarWhereInput>
  }

  export type free_courseUncheckedUpdateManyWithoutAttachementInput = {
    create?: XOR<Enumerable<free_courseCreateWithoutAttachementInput>, Enumerable<free_courseUncheckedCreateWithoutAttachementInput>>
    connectOrCreate?: Enumerable<free_courseCreateOrConnectWithoutAttachementInput>
    upsert?: Enumerable<free_courseUpsertWithWhereUniqueWithoutAttachementInput>
    createMany?: free_courseCreateManyAttachementInputEnvelope
    connect?: Enumerable<free_courseWhereUniqueInput>
    set?: Enumerable<free_courseWhereUniqueInput>
    disconnect?: Enumerable<free_courseWhereUniqueInput>
    delete?: Enumerable<free_courseWhereUniqueInput>
    update?: Enumerable<free_courseUpdateWithWhereUniqueWithoutAttachementInput>
    updateMany?: Enumerable<free_courseUpdateManyWithWhereWithoutAttachementInput>
    deleteMany?: Enumerable<free_courseScalarWhereInput>
  }

  export type attachementCreateNestedOneWithoutFree_courseInput = {
    create?: XOR<attachementCreateWithoutFree_courseInput, attachementUncheckedCreateWithoutFree_courseInput>
    connectOrCreate?: attachementCreateOrConnectWithoutFree_courseInput
    connect?: attachementWhereUniqueInput
  }

  export type teacherCreateNestedOneWithoutFree_courseInput = {
    create?: XOR<teacherCreateWithoutFree_courseInput, teacherUncheckedCreateWithoutFree_courseInput>
    connectOrCreate?: teacherCreateOrConnectWithoutFree_courseInput
    connect?: teacherWhereUniqueInput
  }

  export type attachementUpdateOneRequiredWithoutFree_courseInput = {
    create?: XOR<attachementCreateWithoutFree_courseInput, attachementUncheckedCreateWithoutFree_courseInput>
    connectOrCreate?: attachementCreateOrConnectWithoutFree_courseInput
    upsert?: attachementUpsertWithoutFree_courseInput
    connect?: attachementWhereUniqueInput
    update?: XOR<attachementUpdateWithoutFree_courseInput, attachementUncheckedUpdateWithoutFree_courseInput>
  }

  export type teacherUpdateOneRequiredWithoutFree_courseInput = {
    create?: XOR<teacherCreateWithoutFree_courseInput, teacherUncheckedCreateWithoutFree_courseInput>
    connectOrCreate?: teacherCreateOrConnectWithoutFree_courseInput
    upsert?: teacherUpsertWithoutFree_courseInput
    connect?: teacherWhereUniqueInput
    update?: XOR<teacherUpdateWithoutFree_courseInput, teacherUncheckedUpdateWithoutFree_courseInput>
  }

  export type studentCreateNestedOneWithoutDMInput = {
    create?: XOR<studentCreateWithoutDMInput, studentUncheckedCreateWithoutDMInput>
    connectOrCreate?: studentCreateOrConnectWithoutDMInput
    connect?: studentWhereUniqueInput
  }

  export type studentUpdateOneRequiredWithoutDMInput = {
    create?: XOR<studentCreateWithoutDMInput, studentUncheckedCreateWithoutDMInput>
    connectOrCreate?: studentCreateOrConnectWithoutDMInput
    upsert?: studentUpsertWithoutDMInput
    connect?: studentWhereUniqueInput
    update?: XOR<studentUpdateWithoutDMInput, studentUncheckedUpdateWithoutDMInput>
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedIntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntFilter
    _avg?: NestedFloatFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    sum?: NestedIntFilter
    _min?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedIntFilter
    _max?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedIntFilter
  }

  export type NestedFloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type NestedStringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntFilter
    _min?: NestedStringFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedStringFilter
    _max?: NestedStringFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedStringFilter
  }

  export type NestedBoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type NestedBoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntFilter
    _min?: NestedBoolFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedBoolFilter
    _max?: NestedBoolFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedBoolFilter
  }

  export type feedbackCreateWithoutStudent_idInput = {
    stars: number
    comment: string
  }

  export type feedbackUncheckedCreateWithoutStudent_idInput = {
    feedback_id?: number
    stars: number
    comment: string
  }

  export type feedbackCreateOrConnectWithoutStudent_idInput = {
    where: feedbackWhereUniqueInput
    create: XOR<feedbackCreateWithoutStudent_idInput, feedbackUncheckedCreateWithoutStudent_idInput>
  }

  export type feedbackCreateManyStudent_idInputEnvelope = {
    data: Enumerable<feedbackCreateManyStudent_idInput>
    skipDuplicates?: boolean
  }

  export type reviewCreateWithoutStudentInput = {
    overallRating: number
    ratesNumber: number
    comments?: string
    teacher: teacherCreateNestedOneWithoutReviewInput
  }

  export type reviewUncheckedCreateWithoutStudentInput = {
    review_id?: number
    overallRating: number
    ratesNumber: number
    teacher_id: number
    comments?: string
  }

  export type reviewCreateOrConnectWithoutStudentInput = {
    where: reviewWhereUniqueInput
    create: XOR<reviewCreateWithoutStudentInput, reviewUncheckedCreateWithoutStudentInput>
  }

  export type reviewCreateManyStudentInputEnvelope = {
    data: Enumerable<reviewCreateManyStudentInput>
    skipDuplicates?: boolean
  }

  export type scheduleCreateWithoutStudent_idInput = {
    day: string
    session: string
    teacher_id: teacherCreateNestedOneWithoutScheduleInput
  }

  export type scheduleUncheckedCreateWithoutStudent_idInput = {
    scheduel_id?: number
    teacher: number
    day: string
    session: string
  }

  export type scheduleCreateOrConnectWithoutStudent_idInput = {
    where: scheduleWhereUniqueInput
    create: XOR<scheduleCreateWithoutStudent_idInput, scheduleUncheckedCreateWithoutStudent_idInput>
  }

  export type scheduleCreateManyStudent_idInputEnvelope = {
    data: Enumerable<scheduleCreateManyStudent_idInput>
    skipDuplicates?: boolean
  }

  export type feedbackUpsertWithWhereUniqueWithoutStudent_idInput = {
    where: feedbackWhereUniqueInput
    update: XOR<feedbackUpdateWithoutStudent_idInput, feedbackUncheckedUpdateWithoutStudent_idInput>
    create: XOR<feedbackCreateWithoutStudent_idInput, feedbackUncheckedCreateWithoutStudent_idInput>
  }

  export type feedbackUpdateWithWhereUniqueWithoutStudent_idInput = {
    where: feedbackWhereUniqueInput
    data: XOR<feedbackUpdateWithoutStudent_idInput, feedbackUncheckedUpdateWithoutStudent_idInput>
  }

  export type feedbackUpdateManyWithWhereWithoutStudent_idInput = {
    where: feedbackScalarWhereInput
    data: XOR<feedbackUpdateManyMutationInput, feedbackUncheckedUpdateManyWithoutDMInput>
  }

  export type feedbackScalarWhereInput = {
    AND?: Enumerable<feedbackScalarWhereInput>
    OR?: Enumerable<feedbackScalarWhereInput>
    NOT?: Enumerable<feedbackScalarWhereInput>
    feedback_id?: IntFilter | number
    student?: IntFilter | number
    stars?: IntFilter | number
    comment?: StringFilter | string
  }

  export type reviewUpsertWithWhereUniqueWithoutStudentInput = {
    where: reviewWhereUniqueInput
    update: XOR<reviewUpdateWithoutStudentInput, reviewUncheckedUpdateWithoutStudentInput>
    create: XOR<reviewCreateWithoutStudentInput, reviewUncheckedCreateWithoutStudentInput>
  }

  export type reviewUpdateWithWhereUniqueWithoutStudentInput = {
    where: reviewWhereUniqueInput
    data: XOR<reviewUpdateWithoutStudentInput, reviewUncheckedUpdateWithoutStudentInput>
  }

  export type reviewUpdateManyWithWhereWithoutStudentInput = {
    where: reviewScalarWhereInput
    data: XOR<reviewUpdateManyMutationInput, reviewUncheckedUpdateManyWithoutReviewInput>
  }

  export type reviewScalarWhereInput = {
    AND?: Enumerable<reviewScalarWhereInput>
    OR?: Enumerable<reviewScalarWhereInput>
    NOT?: Enumerable<reviewScalarWhereInput>
    review_id?: IntFilter | number
    overallRating?: IntFilter | number
    ratesNumber?: IntFilter | number
    student_id?: IntFilter | number
    teacher_id?: IntFilter | number
    comments?: StringFilter | string
  }

  export type scheduleUpsertWithWhereUniqueWithoutStudent_idInput = {
    where: scheduleWhereUniqueInput
    update: XOR<scheduleUpdateWithoutStudent_idInput, scheduleUncheckedUpdateWithoutStudent_idInput>
    create: XOR<scheduleCreateWithoutStudent_idInput, scheduleUncheckedCreateWithoutStudent_idInput>
  }

  export type scheduleUpdateWithWhereUniqueWithoutStudent_idInput = {
    where: scheduleWhereUniqueInput
    data: XOR<scheduleUpdateWithoutStudent_idInput, scheduleUncheckedUpdateWithoutStudent_idInput>
  }

  export type scheduleUpdateManyWithWhereWithoutStudent_idInput = {
    where: scheduleScalarWhereInput
    data: XOR<scheduleUpdateManyMutationInput, scheduleUncheckedUpdateManyWithoutScheduleInput>
  }

  export type scheduleScalarWhereInput = {
    AND?: Enumerable<scheduleScalarWhereInput>
    OR?: Enumerable<scheduleScalarWhereInput>
    NOT?: Enumerable<scheduleScalarWhereInput>
    scheduel_id?: IntFilter | number
    student?: IntFilter | number
    teacher?: IntFilter | number
    day?: StringFilter | string
    session?: StringFilter | string
  }

  export type free_courseCreateWithoutTeacher_idInput = {
    title: string
    category: string
    Status?: string
    image: string
    attachement: attachementCreateNestedOneWithoutFree_courseInput
  }

  export type free_courseUncheckedCreateWithoutTeacher_idInput = {
    freeCourse_id?: number
    title: string
    category: string
    Status?: string
    document: number
    image: string
  }

  export type free_courseCreateOrConnectWithoutTeacher_idInput = {
    where: free_courseWhereUniqueInput
    create: XOR<free_courseCreateWithoutTeacher_idInput, free_courseUncheckedCreateWithoutTeacher_idInput>
  }

  export type free_courseCreateManyTeacher_idInputEnvelope = {
    data: Enumerable<free_courseCreateManyTeacher_idInput>
    skipDuplicates?: boolean
  }

  export type postCreateWithoutAuthorInput = {
    Image: string
    status?: string
    body: string
    title: string
    price: number
  }

  export type postUncheckedCreateWithoutAuthorInput = {
    post_id?: number
    Image: string
    status?: string
    body: string
    title: string
    price: number
  }

  export type postCreateOrConnectWithoutAuthorInput = {
    where: postWhereUniqueInput
    create: XOR<postCreateWithoutAuthorInput, postUncheckedCreateWithoutAuthorInput>
  }

  export type postCreateManyAuthorInputEnvelope = {
    data: Enumerable<postCreateManyAuthorInput>
    skipDuplicates?: boolean
  }

  export type reviewCreateWithoutTeacherInput = {
    overallRating: number
    ratesNumber: number
    comments?: string
    student: studentCreateNestedOneWithoutReviewInput
  }

  export type reviewUncheckedCreateWithoutTeacherInput = {
    review_id?: number
    overallRating: number
    ratesNumber: number
    student_id: number
    comments?: string
  }

  export type reviewCreateOrConnectWithoutTeacherInput = {
    where: reviewWhereUniqueInput
    create: XOR<reviewCreateWithoutTeacherInput, reviewUncheckedCreateWithoutTeacherInput>
  }

  export type reviewCreateManyTeacherInputEnvelope = {
    data: Enumerable<reviewCreateManyTeacherInput>
    skipDuplicates?: boolean
  }

  export type scheduleCreateWithoutTeacher_idInput = {
    day: string
    session: string
    student_id: studentCreateNestedOneWithoutScheduleInput
  }

  export type scheduleUncheckedCreateWithoutTeacher_idInput = {
    scheduel_id?: number
    student: number
    day: string
    session: string
  }

  export type scheduleCreateOrConnectWithoutTeacher_idInput = {
    where: scheduleWhereUniqueInput
    create: XOR<scheduleCreateWithoutTeacher_idInput, scheduleUncheckedCreateWithoutTeacher_idInput>
  }

  export type scheduleCreateManyTeacher_idInputEnvelope = {
    data: Enumerable<scheduleCreateManyTeacher_idInput>
    skipDuplicates?: boolean
  }

  export type sessionsCreateWithoutTeacherInput = {
    one?: boolean
    two?: boolean
    three?: boolean
    four?: boolean
    five?: boolean
    six?: boolean
  }

  export type sessionsUncheckedCreateWithoutTeacherInput = {
    sessions_id?: number
    one?: boolean
    two?: boolean
    three?: boolean
    four?: boolean
    five?: boolean
    six?: boolean
  }

  export type sessionsCreateOrConnectWithoutTeacherInput = {
    where: sessionsWhereUniqueInput
    create: XOR<sessionsCreateWithoutTeacherInput, sessionsUncheckedCreateWithoutTeacherInput>
  }

  export type weekDayCreateWithoutTeacherInput = {
    monday?: boolean
    tuesday?: boolean
    wednesday?: boolean
    thursday?: boolean
    friday?: boolean
    saturday?: boolean
    sunday?: boolean
  }

  export type weekDayUncheckedCreateWithoutTeacherInput = {
    weekDay_id?: number
    monday?: boolean
    tuesday?: boolean
    wednesday?: boolean
    thursday?: boolean
    friday?: boolean
    saturday?: boolean
    sunday?: boolean
  }

  export type weekDayCreateOrConnectWithoutTeacherInput = {
    where: weekDayWhereUniqueInput
    create: XOR<weekDayCreateWithoutTeacherInput, weekDayUncheckedCreateWithoutTeacherInput>
  }

  export type free_courseUpsertWithWhereUniqueWithoutTeacher_idInput = {
    where: free_courseWhereUniqueInput
    update: XOR<free_courseUpdateWithoutTeacher_idInput, free_courseUncheckedUpdateWithoutTeacher_idInput>
    create: XOR<free_courseCreateWithoutTeacher_idInput, free_courseUncheckedCreateWithoutTeacher_idInput>
  }

  export type free_courseUpdateWithWhereUniqueWithoutTeacher_idInput = {
    where: free_courseWhereUniqueInput
    data: XOR<free_courseUpdateWithoutTeacher_idInput, free_courseUncheckedUpdateWithoutTeacher_idInput>
  }

  export type free_courseUpdateManyWithWhereWithoutTeacher_idInput = {
    where: free_courseScalarWhereInput
    data: XOR<free_courseUpdateManyMutationInput, free_courseUncheckedUpdateManyWithoutFree_courseInput>
  }

  export type free_courseScalarWhereInput = {
    AND?: Enumerable<free_courseScalarWhereInput>
    OR?: Enumerable<free_courseScalarWhereInput>
    NOT?: Enumerable<free_courseScalarWhereInput>
    freeCourse_id?: IntFilter | number
    teacher?: IntFilter | number
    title?: StringFilter | string
    category?: StringFilter | string
    Status?: StringFilter | string
    document?: IntFilter | number
    image?: StringFilter | string
  }

  export type postUpsertWithWhereUniqueWithoutAuthorInput = {
    where: postWhereUniqueInput
    update: XOR<postUpdateWithoutAuthorInput, postUncheckedUpdateWithoutAuthorInput>
    create: XOR<postCreateWithoutAuthorInput, postUncheckedCreateWithoutAuthorInput>
  }

  export type postUpdateWithWhereUniqueWithoutAuthorInput = {
    where: postWhereUniqueInput
    data: XOR<postUpdateWithoutAuthorInput, postUncheckedUpdateWithoutAuthorInput>
  }

  export type postUpdateManyWithWhereWithoutAuthorInput = {
    where: postScalarWhereInput
    data: XOR<postUpdateManyMutationInput, postUncheckedUpdateManyWithoutPostInput>
  }

  export type postScalarWhereInput = {
    AND?: Enumerable<postScalarWhereInput>
    OR?: Enumerable<postScalarWhereInput>
    NOT?: Enumerable<postScalarWhereInput>
    post_id?: IntFilter | number
    author_id?: IntFilter | number
    Image?: StringFilter | string
    status?: StringFilter | string
    body?: StringFilter | string
    title?: StringFilter | string
    price?: IntFilter | number
  }

  export type reviewUpsertWithWhereUniqueWithoutTeacherInput = {
    where: reviewWhereUniqueInput
    update: XOR<reviewUpdateWithoutTeacherInput, reviewUncheckedUpdateWithoutTeacherInput>
    create: XOR<reviewCreateWithoutTeacherInput, reviewUncheckedCreateWithoutTeacherInput>
  }

  export type reviewUpdateWithWhereUniqueWithoutTeacherInput = {
    where: reviewWhereUniqueInput
    data: XOR<reviewUpdateWithoutTeacherInput, reviewUncheckedUpdateWithoutTeacherInput>
  }

  export type reviewUpdateManyWithWhereWithoutTeacherInput = {
    where: reviewScalarWhereInput
    data: XOR<reviewUpdateManyMutationInput, reviewUncheckedUpdateManyWithoutReviewInput>
  }

  export type scheduleUpsertWithWhereUniqueWithoutTeacher_idInput = {
    where: scheduleWhereUniqueInput
    update: XOR<scheduleUpdateWithoutTeacher_idInput, scheduleUncheckedUpdateWithoutTeacher_idInput>
    create: XOR<scheduleCreateWithoutTeacher_idInput, scheduleUncheckedCreateWithoutTeacher_idInput>
  }

  export type scheduleUpdateWithWhereUniqueWithoutTeacher_idInput = {
    where: scheduleWhereUniqueInput
    data: XOR<scheduleUpdateWithoutTeacher_idInput, scheduleUncheckedUpdateWithoutTeacher_idInput>
  }

  export type scheduleUpdateManyWithWhereWithoutTeacher_idInput = {
    where: scheduleScalarWhereInput
    data: XOR<scheduleUpdateManyMutationInput, scheduleUncheckedUpdateManyWithoutScheduleInput>
  }

  export type sessionsUpsertWithoutTeacherInput = {
    update: XOR<sessionsUpdateWithoutTeacherInput, sessionsUncheckedUpdateWithoutTeacherInput>
    create: XOR<sessionsCreateWithoutTeacherInput, sessionsUncheckedCreateWithoutTeacherInput>
  }

  export type sessionsUpdateWithoutTeacherInput = {
    one?: BoolFieldUpdateOperationsInput | boolean
    two?: BoolFieldUpdateOperationsInput | boolean
    three?: BoolFieldUpdateOperationsInput | boolean
    four?: BoolFieldUpdateOperationsInput | boolean
    five?: BoolFieldUpdateOperationsInput | boolean
    six?: BoolFieldUpdateOperationsInput | boolean
  }

  export type sessionsUncheckedUpdateWithoutTeacherInput = {
    sessions_id?: IntFieldUpdateOperationsInput | number
    one?: BoolFieldUpdateOperationsInput | boolean
    two?: BoolFieldUpdateOperationsInput | boolean
    three?: BoolFieldUpdateOperationsInput | boolean
    four?: BoolFieldUpdateOperationsInput | boolean
    five?: BoolFieldUpdateOperationsInput | boolean
    six?: BoolFieldUpdateOperationsInput | boolean
  }

  export type weekDayUpsertWithoutTeacherInput = {
    update: XOR<weekDayUpdateWithoutTeacherInput, weekDayUncheckedUpdateWithoutTeacherInput>
    create: XOR<weekDayCreateWithoutTeacherInput, weekDayUncheckedCreateWithoutTeacherInput>
  }

  export type weekDayUpdateWithoutTeacherInput = {
    monday?: BoolFieldUpdateOperationsInput | boolean
    tuesday?: BoolFieldUpdateOperationsInput | boolean
    wednesday?: BoolFieldUpdateOperationsInput | boolean
    thursday?: BoolFieldUpdateOperationsInput | boolean
    friday?: BoolFieldUpdateOperationsInput | boolean
    saturday?: BoolFieldUpdateOperationsInput | boolean
    sunday?: BoolFieldUpdateOperationsInput | boolean
  }

  export type weekDayUncheckedUpdateWithoutTeacherInput = {
    weekDay_id?: IntFieldUpdateOperationsInput | number
    monday?: BoolFieldUpdateOperationsInput | boolean
    tuesday?: BoolFieldUpdateOperationsInput | boolean
    wednesday?: BoolFieldUpdateOperationsInput | boolean
    thursday?: BoolFieldUpdateOperationsInput | boolean
    friday?: BoolFieldUpdateOperationsInput | boolean
    saturday?: BoolFieldUpdateOperationsInput | boolean
    sunday?: BoolFieldUpdateOperationsInput | boolean
  }

  export type teacherCreateWithoutWeekDayInput = {
    sumOfRates?: number
    email: string
    userName: string
    password: string
    education: string
    description?: string
    age: number
    wallet?: number
    image: string
    token?: string
    Overall_rating?: number
    numberOfRates?: number
    free_course?: free_courseCreateNestedManyWithoutTeacher_idInput
    post?: postCreateNestedManyWithoutAuthorInput
    review?: reviewCreateNestedManyWithoutTeacherInput
    schedule?: scheduleCreateNestedManyWithoutTeacher_idInput
    sessions?: sessionsCreateNestedOneWithoutTeacherInput
  }

  export type teacherUncheckedCreateWithoutWeekDayInput = {
    teacher_id?: number
    sumOfRates?: number
    email: string
    userName: string
    password: string
    education: string
    description?: string
    age: number
    wallet?: number
    image: string
    token?: string
    Overall_rating?: number
    numberOfRates?: number
    free_course?: free_courseUncheckedCreateNestedManyWithoutTeacher_idInput
    post?: postUncheckedCreateNestedManyWithoutAuthorInput
    review?: reviewUncheckedCreateNestedManyWithoutTeacherInput
    schedule?: scheduleUncheckedCreateNestedManyWithoutTeacher_idInput
    sessions?: sessionsUncheckedCreateNestedOneWithoutTeacherInput
  }

  export type teacherCreateOrConnectWithoutWeekDayInput = {
    where: teacherWhereUniqueInput
    create: XOR<teacherCreateWithoutWeekDayInput, teacherUncheckedCreateWithoutWeekDayInput>
  }

  export type teacherUpsertWithoutWeekDayInput = {
    update: XOR<teacherUpdateWithoutWeekDayInput, teacherUncheckedUpdateWithoutWeekDayInput>
    create: XOR<teacherCreateWithoutWeekDayInput, teacherUncheckedCreateWithoutWeekDayInput>
  }

  export type teacherUpdateWithoutWeekDayInput = {
    sumOfRates?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    education?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    wallet?: IntFieldUpdateOperationsInput | number
    image?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    Overall_rating?: IntFieldUpdateOperationsInput | number
    numberOfRates?: IntFieldUpdateOperationsInput | number
    free_course?: free_courseUpdateManyWithoutTeacher_idInput
    post?: postUpdateManyWithoutAuthorInput
    review?: reviewUpdateManyWithoutTeacherInput
    schedule?: scheduleUpdateManyWithoutTeacher_idInput
    sessions?: sessionsUpdateOneWithoutTeacherInput
  }

  export type teacherUncheckedUpdateWithoutWeekDayInput = {
    teacher_id?: IntFieldUpdateOperationsInput | number
    sumOfRates?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    education?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    wallet?: IntFieldUpdateOperationsInput | number
    image?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    Overall_rating?: IntFieldUpdateOperationsInput | number
    numberOfRates?: IntFieldUpdateOperationsInput | number
    free_course?: free_courseUncheckedUpdateManyWithoutTeacher_idInput
    post?: postUncheckedUpdateManyWithoutAuthorInput
    review?: reviewUncheckedUpdateManyWithoutTeacherInput
    schedule?: scheduleUncheckedUpdateManyWithoutTeacher_idInput
    sessions?: sessionsUncheckedUpdateOneWithoutTeacherInput
  }

  export type teacherCreateWithoutSessionsInput = {
    sumOfRates?: number
    email: string
    userName: string
    password: string
    education: string
    description?: string
    age: number
    wallet?: number
    image: string
    token?: string
    Overall_rating?: number
    numberOfRates?: number
    free_course?: free_courseCreateNestedManyWithoutTeacher_idInput
    post?: postCreateNestedManyWithoutAuthorInput
    review?: reviewCreateNestedManyWithoutTeacherInput
    schedule?: scheduleCreateNestedManyWithoutTeacher_idInput
    weekDay?: weekDayCreateNestedOneWithoutTeacherInput
  }

  export type teacherUncheckedCreateWithoutSessionsInput = {
    teacher_id?: number
    sumOfRates?: number
    email: string
    userName: string
    password: string
    education: string
    description?: string
    age: number
    wallet?: number
    image: string
    token?: string
    Overall_rating?: number
    numberOfRates?: number
    free_course?: free_courseUncheckedCreateNestedManyWithoutTeacher_idInput
    post?: postUncheckedCreateNestedManyWithoutAuthorInput
    review?: reviewUncheckedCreateNestedManyWithoutTeacherInput
    schedule?: scheduleUncheckedCreateNestedManyWithoutTeacher_idInput
    weekDay?: weekDayUncheckedCreateNestedOneWithoutTeacherInput
  }

  export type teacherCreateOrConnectWithoutSessionsInput = {
    where: teacherWhereUniqueInput
    create: XOR<teacherCreateWithoutSessionsInput, teacherUncheckedCreateWithoutSessionsInput>
  }

  export type teacherUpsertWithoutSessionsInput = {
    update: XOR<teacherUpdateWithoutSessionsInput, teacherUncheckedUpdateWithoutSessionsInput>
    create: XOR<teacherCreateWithoutSessionsInput, teacherUncheckedCreateWithoutSessionsInput>
  }

  export type teacherUpdateWithoutSessionsInput = {
    sumOfRates?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    education?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    wallet?: IntFieldUpdateOperationsInput | number
    image?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    Overall_rating?: IntFieldUpdateOperationsInput | number
    numberOfRates?: IntFieldUpdateOperationsInput | number
    free_course?: free_courseUpdateManyWithoutTeacher_idInput
    post?: postUpdateManyWithoutAuthorInput
    review?: reviewUpdateManyWithoutTeacherInput
    schedule?: scheduleUpdateManyWithoutTeacher_idInput
    weekDay?: weekDayUpdateOneWithoutTeacherInput
  }

  export type teacherUncheckedUpdateWithoutSessionsInput = {
    teacher_id?: IntFieldUpdateOperationsInput | number
    sumOfRates?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    education?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    wallet?: IntFieldUpdateOperationsInput | number
    image?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    Overall_rating?: IntFieldUpdateOperationsInput | number
    numberOfRates?: IntFieldUpdateOperationsInput | number
    free_course?: free_courseUncheckedUpdateManyWithoutTeacher_idInput
    post?: postUncheckedUpdateManyWithoutAuthorInput
    review?: reviewUncheckedUpdateManyWithoutTeacherInput
    schedule?: scheduleUncheckedUpdateManyWithoutTeacher_idInput
    weekDay?: weekDayUncheckedUpdateOneWithoutTeacherInput
  }

  export type teacherCreateWithoutPostInput = {
    sumOfRates?: number
    email: string
    userName: string
    password: string
    education: string
    description?: string
    age: number
    wallet?: number
    image: string
    token?: string
    Overall_rating?: number
    numberOfRates?: number
    free_course?: free_courseCreateNestedManyWithoutTeacher_idInput
    review?: reviewCreateNestedManyWithoutTeacherInput
    schedule?: scheduleCreateNestedManyWithoutTeacher_idInput
    sessions?: sessionsCreateNestedOneWithoutTeacherInput
    weekDay?: weekDayCreateNestedOneWithoutTeacherInput
  }

  export type teacherUncheckedCreateWithoutPostInput = {
    teacher_id?: number
    sumOfRates?: number
    email: string
    userName: string
    password: string
    education: string
    description?: string
    age: number
    wallet?: number
    image: string
    token?: string
    Overall_rating?: number
    numberOfRates?: number
    free_course?: free_courseUncheckedCreateNestedManyWithoutTeacher_idInput
    review?: reviewUncheckedCreateNestedManyWithoutTeacherInput
    schedule?: scheduleUncheckedCreateNestedManyWithoutTeacher_idInput
    sessions?: sessionsUncheckedCreateNestedOneWithoutTeacherInput
    weekDay?: weekDayUncheckedCreateNestedOneWithoutTeacherInput
  }

  export type teacherCreateOrConnectWithoutPostInput = {
    where: teacherWhereUniqueInput
    create: XOR<teacherCreateWithoutPostInput, teacherUncheckedCreateWithoutPostInput>
  }

  export type teacherUpsertWithoutPostInput = {
    update: XOR<teacherUpdateWithoutPostInput, teacherUncheckedUpdateWithoutPostInput>
    create: XOR<teacherCreateWithoutPostInput, teacherUncheckedCreateWithoutPostInput>
  }

  export type teacherUpdateWithoutPostInput = {
    sumOfRates?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    education?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    wallet?: IntFieldUpdateOperationsInput | number
    image?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    Overall_rating?: IntFieldUpdateOperationsInput | number
    numberOfRates?: IntFieldUpdateOperationsInput | number
    free_course?: free_courseUpdateManyWithoutTeacher_idInput
    review?: reviewUpdateManyWithoutTeacherInput
    schedule?: scheduleUpdateManyWithoutTeacher_idInput
    sessions?: sessionsUpdateOneWithoutTeacherInput
    weekDay?: weekDayUpdateOneWithoutTeacherInput
  }

  export type teacherUncheckedUpdateWithoutPostInput = {
    teacher_id?: IntFieldUpdateOperationsInput | number
    sumOfRates?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    education?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    wallet?: IntFieldUpdateOperationsInput | number
    image?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    Overall_rating?: IntFieldUpdateOperationsInput | number
    numberOfRates?: IntFieldUpdateOperationsInput | number
    free_course?: free_courseUncheckedUpdateManyWithoutTeacher_idInput
    review?: reviewUncheckedUpdateManyWithoutTeacherInput
    schedule?: scheduleUncheckedUpdateManyWithoutTeacher_idInput
    sessions?: sessionsUncheckedUpdateOneWithoutTeacherInput
    weekDay?: weekDayUncheckedUpdateOneWithoutTeacherInput
  }

  export type studentCreateWithoutReviewInput = {
    userName: string
    password: string
    education: string
    age: number
    wallet?: number
    image: string
    email: string
    token?: string
    DM?: feedbackCreateNestedManyWithoutStudent_idInput
    schedule?: scheduleCreateNestedManyWithoutStudent_idInput
  }

  export type studentUncheckedCreateWithoutReviewInput = {
    student_id?: number
    userName: string
    password: string
    education: string
    age: number
    wallet?: number
    image: string
    email: string
    token?: string
    DM?: feedbackUncheckedCreateNestedManyWithoutStudent_idInput
    schedule?: scheduleUncheckedCreateNestedManyWithoutStudent_idInput
  }

  export type studentCreateOrConnectWithoutReviewInput = {
    where: studentWhereUniqueInput
    create: XOR<studentCreateWithoutReviewInput, studentUncheckedCreateWithoutReviewInput>
  }

  export type teacherCreateWithoutReviewInput = {
    sumOfRates?: number
    email: string
    userName: string
    password: string
    education: string
    description?: string
    age: number
    wallet?: number
    image: string
    token?: string
    Overall_rating?: number
    numberOfRates?: number
    free_course?: free_courseCreateNestedManyWithoutTeacher_idInput
    post?: postCreateNestedManyWithoutAuthorInput
    schedule?: scheduleCreateNestedManyWithoutTeacher_idInput
    sessions?: sessionsCreateNestedOneWithoutTeacherInput
    weekDay?: weekDayCreateNestedOneWithoutTeacherInput
  }

  export type teacherUncheckedCreateWithoutReviewInput = {
    teacher_id?: number
    sumOfRates?: number
    email: string
    userName: string
    password: string
    education: string
    description?: string
    age: number
    wallet?: number
    image: string
    token?: string
    Overall_rating?: number
    numberOfRates?: number
    free_course?: free_courseUncheckedCreateNestedManyWithoutTeacher_idInput
    post?: postUncheckedCreateNestedManyWithoutAuthorInput
    schedule?: scheduleUncheckedCreateNestedManyWithoutTeacher_idInput
    sessions?: sessionsUncheckedCreateNestedOneWithoutTeacherInput
    weekDay?: weekDayUncheckedCreateNestedOneWithoutTeacherInput
  }

  export type teacherCreateOrConnectWithoutReviewInput = {
    where: teacherWhereUniqueInput
    create: XOR<teacherCreateWithoutReviewInput, teacherUncheckedCreateWithoutReviewInput>
  }

  export type studentUpsertWithoutReviewInput = {
    update: XOR<studentUpdateWithoutReviewInput, studentUncheckedUpdateWithoutReviewInput>
    create: XOR<studentCreateWithoutReviewInput, studentUncheckedCreateWithoutReviewInput>
  }

  export type studentUpdateWithoutReviewInput = {
    userName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    education?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    wallet?: IntFieldUpdateOperationsInput | number
    image?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    DM?: feedbackUpdateManyWithoutStudent_idInput
    schedule?: scheduleUpdateManyWithoutStudent_idInput
  }

  export type studentUncheckedUpdateWithoutReviewInput = {
    student_id?: IntFieldUpdateOperationsInput | number
    userName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    education?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    wallet?: IntFieldUpdateOperationsInput | number
    image?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    DM?: feedbackUncheckedUpdateManyWithoutStudent_idInput
    schedule?: scheduleUncheckedUpdateManyWithoutStudent_idInput
  }

  export type teacherUpsertWithoutReviewInput = {
    update: XOR<teacherUpdateWithoutReviewInput, teacherUncheckedUpdateWithoutReviewInput>
    create: XOR<teacherCreateWithoutReviewInput, teacherUncheckedCreateWithoutReviewInput>
  }

  export type teacherUpdateWithoutReviewInput = {
    sumOfRates?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    education?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    wallet?: IntFieldUpdateOperationsInput | number
    image?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    Overall_rating?: IntFieldUpdateOperationsInput | number
    numberOfRates?: IntFieldUpdateOperationsInput | number
    free_course?: free_courseUpdateManyWithoutTeacher_idInput
    post?: postUpdateManyWithoutAuthorInput
    schedule?: scheduleUpdateManyWithoutTeacher_idInput
    sessions?: sessionsUpdateOneWithoutTeacherInput
    weekDay?: weekDayUpdateOneWithoutTeacherInput
  }

  export type teacherUncheckedUpdateWithoutReviewInput = {
    teacher_id?: IntFieldUpdateOperationsInput | number
    sumOfRates?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    education?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    wallet?: IntFieldUpdateOperationsInput | number
    image?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    Overall_rating?: IntFieldUpdateOperationsInput | number
    numberOfRates?: IntFieldUpdateOperationsInput | number
    free_course?: free_courseUncheckedUpdateManyWithoutTeacher_idInput
    post?: postUncheckedUpdateManyWithoutAuthorInput
    schedule?: scheduleUncheckedUpdateManyWithoutTeacher_idInput
    sessions?: sessionsUncheckedUpdateOneWithoutTeacherInput
    weekDay?: weekDayUncheckedUpdateOneWithoutTeacherInput
  }

  export type studentCreateWithoutScheduleInput = {
    userName: string
    password: string
    education: string
    age: number
    wallet?: number
    image: string
    email: string
    token?: string
    DM?: feedbackCreateNestedManyWithoutStudent_idInput
    review?: reviewCreateNestedManyWithoutStudentInput
  }

  export type studentUncheckedCreateWithoutScheduleInput = {
    student_id?: number
    userName: string
    password: string
    education: string
    age: number
    wallet?: number
    image: string
    email: string
    token?: string
    DM?: feedbackUncheckedCreateNestedManyWithoutStudent_idInput
    review?: reviewUncheckedCreateNestedManyWithoutStudentInput
  }

  export type studentCreateOrConnectWithoutScheduleInput = {
    where: studentWhereUniqueInput
    create: XOR<studentCreateWithoutScheduleInput, studentUncheckedCreateWithoutScheduleInput>
  }

  export type teacherCreateWithoutScheduleInput = {
    sumOfRates?: number
    email: string
    userName: string
    password: string
    education: string
    description?: string
    age: number
    wallet?: number
    image: string
    token?: string
    Overall_rating?: number
    numberOfRates?: number
    free_course?: free_courseCreateNestedManyWithoutTeacher_idInput
    post?: postCreateNestedManyWithoutAuthorInput
    review?: reviewCreateNestedManyWithoutTeacherInput
    sessions?: sessionsCreateNestedOneWithoutTeacherInput
    weekDay?: weekDayCreateNestedOneWithoutTeacherInput
  }

  export type teacherUncheckedCreateWithoutScheduleInput = {
    teacher_id?: number
    sumOfRates?: number
    email: string
    userName: string
    password: string
    education: string
    description?: string
    age: number
    wallet?: number
    image: string
    token?: string
    Overall_rating?: number
    numberOfRates?: number
    free_course?: free_courseUncheckedCreateNestedManyWithoutTeacher_idInput
    post?: postUncheckedCreateNestedManyWithoutAuthorInput
    review?: reviewUncheckedCreateNestedManyWithoutTeacherInput
    sessions?: sessionsUncheckedCreateNestedOneWithoutTeacherInput
    weekDay?: weekDayUncheckedCreateNestedOneWithoutTeacherInput
  }

  export type teacherCreateOrConnectWithoutScheduleInput = {
    where: teacherWhereUniqueInput
    create: XOR<teacherCreateWithoutScheduleInput, teacherUncheckedCreateWithoutScheduleInput>
  }

  export type studentUpsertWithoutScheduleInput = {
    update: XOR<studentUpdateWithoutScheduleInput, studentUncheckedUpdateWithoutScheduleInput>
    create: XOR<studentCreateWithoutScheduleInput, studentUncheckedCreateWithoutScheduleInput>
  }

  export type studentUpdateWithoutScheduleInput = {
    userName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    education?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    wallet?: IntFieldUpdateOperationsInput | number
    image?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    DM?: feedbackUpdateManyWithoutStudent_idInput
    review?: reviewUpdateManyWithoutStudentInput
  }

  export type studentUncheckedUpdateWithoutScheduleInput = {
    student_id?: IntFieldUpdateOperationsInput | number
    userName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    education?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    wallet?: IntFieldUpdateOperationsInput | number
    image?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    DM?: feedbackUncheckedUpdateManyWithoutStudent_idInput
    review?: reviewUncheckedUpdateManyWithoutStudentInput
  }

  export type teacherUpsertWithoutScheduleInput = {
    update: XOR<teacherUpdateWithoutScheduleInput, teacherUncheckedUpdateWithoutScheduleInput>
    create: XOR<teacherCreateWithoutScheduleInput, teacherUncheckedCreateWithoutScheduleInput>
  }

  export type teacherUpdateWithoutScheduleInput = {
    sumOfRates?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    education?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    wallet?: IntFieldUpdateOperationsInput | number
    image?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    Overall_rating?: IntFieldUpdateOperationsInput | number
    numberOfRates?: IntFieldUpdateOperationsInput | number
    free_course?: free_courseUpdateManyWithoutTeacher_idInput
    post?: postUpdateManyWithoutAuthorInput
    review?: reviewUpdateManyWithoutTeacherInput
    sessions?: sessionsUpdateOneWithoutTeacherInput
    weekDay?: weekDayUpdateOneWithoutTeacherInput
  }

  export type teacherUncheckedUpdateWithoutScheduleInput = {
    teacher_id?: IntFieldUpdateOperationsInput | number
    sumOfRates?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    education?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    wallet?: IntFieldUpdateOperationsInput | number
    image?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    Overall_rating?: IntFieldUpdateOperationsInput | number
    numberOfRates?: IntFieldUpdateOperationsInput | number
    free_course?: free_courseUncheckedUpdateManyWithoutTeacher_idInput
    post?: postUncheckedUpdateManyWithoutAuthorInput
    review?: reviewUncheckedUpdateManyWithoutTeacherInput
    sessions?: sessionsUncheckedUpdateOneWithoutTeacherInput
    weekDay?: weekDayUncheckedUpdateOneWithoutTeacherInput
  }

  export type free_courseCreateWithoutAttachementInput = {
    title: string
    category: string
    Status?: string
    image: string
    teacher_id: teacherCreateNestedOneWithoutFree_courseInput
  }

  export type free_courseUncheckedCreateWithoutAttachementInput = {
    freeCourse_id?: number
    teacher: number
    title: string
    category: string
    Status?: string
    image: string
  }

  export type free_courseCreateOrConnectWithoutAttachementInput = {
    where: free_courseWhereUniqueInput
    create: XOR<free_courseCreateWithoutAttachementInput, free_courseUncheckedCreateWithoutAttachementInput>
  }

  export type free_courseCreateManyAttachementInputEnvelope = {
    data: Enumerable<free_courseCreateManyAttachementInput>
    skipDuplicates?: boolean
  }

  export type free_courseUpsertWithWhereUniqueWithoutAttachementInput = {
    where: free_courseWhereUniqueInput
    update: XOR<free_courseUpdateWithoutAttachementInput, free_courseUncheckedUpdateWithoutAttachementInput>
    create: XOR<free_courseCreateWithoutAttachementInput, free_courseUncheckedCreateWithoutAttachementInput>
  }

  export type free_courseUpdateWithWhereUniqueWithoutAttachementInput = {
    where: free_courseWhereUniqueInput
    data: XOR<free_courseUpdateWithoutAttachementInput, free_courseUncheckedUpdateWithoutAttachementInput>
  }

  export type free_courseUpdateManyWithWhereWithoutAttachementInput = {
    where: free_courseScalarWhereInput
    data: XOR<free_courseUpdateManyMutationInput, free_courseUncheckedUpdateManyWithoutFree_courseInput>
  }

  export type attachementCreateWithoutFree_courseInput = {
    Type: string
    attachement: string
    body: string
  }

  export type attachementUncheckedCreateWithoutFree_courseInput = {
    attachement_id?: number
    Type: string
    attachement: string
    body: string
  }

  export type attachementCreateOrConnectWithoutFree_courseInput = {
    where: attachementWhereUniqueInput
    create: XOR<attachementCreateWithoutFree_courseInput, attachementUncheckedCreateWithoutFree_courseInput>
  }

  export type teacherCreateWithoutFree_courseInput = {
    sumOfRates?: number
    email: string
    userName: string
    password: string
    education: string
    description?: string
    age: number
    wallet?: number
    image: string
    token?: string
    Overall_rating?: number
    numberOfRates?: number
    post?: postCreateNestedManyWithoutAuthorInput
    review?: reviewCreateNestedManyWithoutTeacherInput
    schedule?: scheduleCreateNestedManyWithoutTeacher_idInput
    sessions?: sessionsCreateNestedOneWithoutTeacherInput
    weekDay?: weekDayCreateNestedOneWithoutTeacherInput
  }

  export type teacherUncheckedCreateWithoutFree_courseInput = {
    teacher_id?: number
    sumOfRates?: number
    email: string
    userName: string
    password: string
    education: string
    description?: string
    age: number
    wallet?: number
    image: string
    token?: string
    Overall_rating?: number
    numberOfRates?: number
    post?: postUncheckedCreateNestedManyWithoutAuthorInput
    review?: reviewUncheckedCreateNestedManyWithoutTeacherInput
    schedule?: scheduleUncheckedCreateNestedManyWithoutTeacher_idInput
    sessions?: sessionsUncheckedCreateNestedOneWithoutTeacherInput
    weekDay?: weekDayUncheckedCreateNestedOneWithoutTeacherInput
  }

  export type teacherCreateOrConnectWithoutFree_courseInput = {
    where: teacherWhereUniqueInput
    create: XOR<teacherCreateWithoutFree_courseInput, teacherUncheckedCreateWithoutFree_courseInput>
  }

  export type attachementUpsertWithoutFree_courseInput = {
    update: XOR<attachementUpdateWithoutFree_courseInput, attachementUncheckedUpdateWithoutFree_courseInput>
    create: XOR<attachementCreateWithoutFree_courseInput, attachementUncheckedCreateWithoutFree_courseInput>
  }

  export type attachementUpdateWithoutFree_courseInput = {
    Type?: StringFieldUpdateOperationsInput | string
    attachement?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
  }

  export type attachementUncheckedUpdateWithoutFree_courseInput = {
    attachement_id?: IntFieldUpdateOperationsInput | number
    Type?: StringFieldUpdateOperationsInput | string
    attachement?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
  }

  export type teacherUpsertWithoutFree_courseInput = {
    update: XOR<teacherUpdateWithoutFree_courseInput, teacherUncheckedUpdateWithoutFree_courseInput>
    create: XOR<teacherCreateWithoutFree_courseInput, teacherUncheckedCreateWithoutFree_courseInput>
  }

  export type teacherUpdateWithoutFree_courseInput = {
    sumOfRates?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    education?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    wallet?: IntFieldUpdateOperationsInput | number
    image?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    Overall_rating?: IntFieldUpdateOperationsInput | number
    numberOfRates?: IntFieldUpdateOperationsInput | number
    post?: postUpdateManyWithoutAuthorInput
    review?: reviewUpdateManyWithoutTeacherInput
    schedule?: scheduleUpdateManyWithoutTeacher_idInput
    sessions?: sessionsUpdateOneWithoutTeacherInput
    weekDay?: weekDayUpdateOneWithoutTeacherInput
  }

  export type teacherUncheckedUpdateWithoutFree_courseInput = {
    teacher_id?: IntFieldUpdateOperationsInput | number
    sumOfRates?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    education?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    wallet?: IntFieldUpdateOperationsInput | number
    image?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    Overall_rating?: IntFieldUpdateOperationsInput | number
    numberOfRates?: IntFieldUpdateOperationsInput | number
    post?: postUncheckedUpdateManyWithoutAuthorInput
    review?: reviewUncheckedUpdateManyWithoutTeacherInput
    schedule?: scheduleUncheckedUpdateManyWithoutTeacher_idInput
    sessions?: sessionsUncheckedUpdateOneWithoutTeacherInput
    weekDay?: weekDayUncheckedUpdateOneWithoutTeacherInput
  }

  export type studentCreateWithoutDMInput = {
    userName: string
    password: string
    education: string
    age: number
    wallet?: number
    image: string
    email: string
    token?: string
    review?: reviewCreateNestedManyWithoutStudentInput
    schedule?: scheduleCreateNestedManyWithoutStudent_idInput
  }

  export type studentUncheckedCreateWithoutDMInput = {
    student_id?: number
    userName: string
    password: string
    education: string
    age: number
    wallet?: number
    image: string
    email: string
    token?: string
    review?: reviewUncheckedCreateNestedManyWithoutStudentInput
    schedule?: scheduleUncheckedCreateNestedManyWithoutStudent_idInput
  }

  export type studentCreateOrConnectWithoutDMInput = {
    where: studentWhereUniqueInput
    create: XOR<studentCreateWithoutDMInput, studentUncheckedCreateWithoutDMInput>
  }

  export type studentUpsertWithoutDMInput = {
    update: XOR<studentUpdateWithoutDMInput, studentUncheckedUpdateWithoutDMInput>
    create: XOR<studentCreateWithoutDMInput, studentUncheckedCreateWithoutDMInput>
  }

  export type studentUpdateWithoutDMInput = {
    userName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    education?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    wallet?: IntFieldUpdateOperationsInput | number
    image?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    review?: reviewUpdateManyWithoutStudentInput
    schedule?: scheduleUpdateManyWithoutStudent_idInput
  }

  export type studentUncheckedUpdateWithoutDMInput = {
    student_id?: IntFieldUpdateOperationsInput | number
    userName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    education?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    wallet?: IntFieldUpdateOperationsInput | number
    image?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    review?: reviewUncheckedUpdateManyWithoutStudentInput
    schedule?: scheduleUncheckedUpdateManyWithoutStudent_idInput
  }

  export type feedbackCreateManyStudent_idInput = {
    feedback_id?: number
    stars: number
    comment: string
  }

  export type reviewCreateManyStudentInput = {
    review_id?: number
    overallRating: number
    ratesNumber: number
    teacher_id: number
    comments?: string
  }

  export type scheduleCreateManyStudent_idInput = {
    scheduel_id?: number
    teacher: number
    day: string
    session: string
  }

  export type feedbackUpdateWithoutStudent_idInput = {
    stars?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
  }

  export type feedbackUncheckedUpdateWithoutStudent_idInput = {
    feedback_id?: IntFieldUpdateOperationsInput | number
    stars?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
  }

  export type feedbackUncheckedUpdateManyWithoutDMInput = {
    feedback_id?: IntFieldUpdateOperationsInput | number
    stars?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
  }

  export type reviewUpdateWithoutStudentInput = {
    overallRating?: IntFieldUpdateOperationsInput | number
    ratesNumber?: IntFieldUpdateOperationsInput | number
    comments?: StringFieldUpdateOperationsInput | string
    teacher?: teacherUpdateOneRequiredWithoutReviewInput
  }

  export type reviewUncheckedUpdateWithoutStudentInput = {
    review_id?: IntFieldUpdateOperationsInput | number
    overallRating?: IntFieldUpdateOperationsInput | number
    ratesNumber?: IntFieldUpdateOperationsInput | number
    teacher_id?: IntFieldUpdateOperationsInput | number
    comments?: StringFieldUpdateOperationsInput | string
  }

  export type reviewUncheckedUpdateManyWithoutReviewInput = {
    review_id?: IntFieldUpdateOperationsInput | number
    overallRating?: IntFieldUpdateOperationsInput | number
    ratesNumber?: IntFieldUpdateOperationsInput | number
    teacher_id?: IntFieldUpdateOperationsInput | number
    comments?: StringFieldUpdateOperationsInput | string
  }

  export type scheduleUpdateWithoutStudent_idInput = {
    day?: StringFieldUpdateOperationsInput | string
    session?: StringFieldUpdateOperationsInput | string
    teacher_id?: teacherUpdateOneRequiredWithoutScheduleInput
  }

  export type scheduleUncheckedUpdateWithoutStudent_idInput = {
    scheduel_id?: IntFieldUpdateOperationsInput | number
    teacher?: IntFieldUpdateOperationsInput | number
    day?: StringFieldUpdateOperationsInput | string
    session?: StringFieldUpdateOperationsInput | string
  }

  export type scheduleUncheckedUpdateManyWithoutScheduleInput = {
    scheduel_id?: IntFieldUpdateOperationsInput | number
    teacher?: IntFieldUpdateOperationsInput | number
    day?: StringFieldUpdateOperationsInput | string
    session?: StringFieldUpdateOperationsInput | string
  }

  export type free_courseCreateManyTeacher_idInput = {
    freeCourse_id?: number
    title: string
    category: string
    Status?: string
    document: number
    image: string
  }

  export type postCreateManyAuthorInput = {
    post_id?: number
    Image: string
    status?: string
    body: string
    title: string
    price: number
  }

  export type reviewCreateManyTeacherInput = {
    review_id?: number
    overallRating: number
    ratesNumber: number
    student_id: number
    comments?: string
  }

  export type scheduleCreateManyTeacher_idInput = {
    scheduel_id?: number
    student: number
    day: string
    session: string
  }

  export type free_courseUpdateWithoutTeacher_idInput = {
    title?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    Status?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    attachement?: attachementUpdateOneRequiredWithoutFree_courseInput
  }

  export type free_courseUncheckedUpdateWithoutTeacher_idInput = {
    freeCourse_id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    Status?: StringFieldUpdateOperationsInput | string
    document?: IntFieldUpdateOperationsInput | number
    image?: StringFieldUpdateOperationsInput | string
  }

  export type free_courseUncheckedUpdateManyWithoutFree_courseInput = {
    freeCourse_id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    Status?: StringFieldUpdateOperationsInput | string
    document?: IntFieldUpdateOperationsInput | number
    image?: StringFieldUpdateOperationsInput | string
  }

  export type postUpdateWithoutAuthorInput = {
    Image?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
  }

  export type postUncheckedUpdateWithoutAuthorInput = {
    post_id?: IntFieldUpdateOperationsInput | number
    Image?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
  }

  export type postUncheckedUpdateManyWithoutPostInput = {
    post_id?: IntFieldUpdateOperationsInput | number
    Image?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
  }

  export type reviewUpdateWithoutTeacherInput = {
    overallRating?: IntFieldUpdateOperationsInput | number
    ratesNumber?: IntFieldUpdateOperationsInput | number
    comments?: StringFieldUpdateOperationsInput | string
    student?: studentUpdateOneRequiredWithoutReviewInput
  }

  export type reviewUncheckedUpdateWithoutTeacherInput = {
    review_id?: IntFieldUpdateOperationsInput | number
    overallRating?: IntFieldUpdateOperationsInput | number
    ratesNumber?: IntFieldUpdateOperationsInput | number
    student_id?: IntFieldUpdateOperationsInput | number
    comments?: StringFieldUpdateOperationsInput | string
  }

  export type scheduleUpdateWithoutTeacher_idInput = {
    day?: StringFieldUpdateOperationsInput | string
    session?: StringFieldUpdateOperationsInput | string
    student_id?: studentUpdateOneRequiredWithoutScheduleInput
  }

  export type scheduleUncheckedUpdateWithoutTeacher_idInput = {
    scheduel_id?: IntFieldUpdateOperationsInput | number
    student?: IntFieldUpdateOperationsInput | number
    day?: StringFieldUpdateOperationsInput | string
    session?: StringFieldUpdateOperationsInput | string
  }

  export type free_courseCreateManyAttachementInput = {
    freeCourse_id?: number
    teacher: number
    title: string
    category: string
    Status?: string
    image: string
  }

  export type free_courseUpdateWithoutAttachementInput = {
    title?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    Status?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    teacher_id?: teacherUpdateOneRequiredWithoutFree_courseInput
  }

  export type free_courseUncheckedUpdateWithoutAttachementInput = {
    freeCourse_id?: IntFieldUpdateOperationsInput | number
    teacher?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    Status?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.DMMF.Document;
}